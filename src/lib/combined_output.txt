lib/
└── lib
    ├── contracts
    │   ├── Implements.ts
    │   ├── index.ts
    │   ├── Interface.ts
    │   └── README.md
    ├── core
    │   ├── guid.ts
    │   ├── index.ts
    │   └── timeout.ts
    ├── eventing
    │   ├── base
    │   │   └── EventArgsBase.ts
    │   ├── behaviours
    │   │   ├── EventBehaviour.ts
    │   │   ├── EventBehaviourHost.tsx
    │   │   ├── index.ts
    │   │   ├── README.md
    │   │   ├── useEventBehaviour.ts
    │   │   └── useEventBehaviourState.ts
    │   ├── components
    │   │   └── EventListener.tsx
    │   ├── contracts
    │   │   └── specs.ts
    │   ├── createEventRegistrar.ts
    │   ├── EventBus.ts
    │   ├── eventLogger.ts
    │   ├── EventRegistrar.ts
    │   ├── events
    │   │   ├── GetLocalPlayerEvent.ts
    │   │   ├── index.ts
    │   │   ├── PlayerJoinedEvent.ts
    │   │   └── PlayerTypes.ts
    │   ├── hooks
    │   │   ├── EventBusContext.ts
    │   │   ├── EventBusProvider.tsx
    │   │   ├── index.ts
    │   │   ├── useEventBus.ts
    │   │   ├── useEventListener.ts
    │   │   └── useEventRegistrar.ts
    │   ├── index.ts
    │   ├── interfaces
    │   │   ├── IEventArgs.ts
    │   │   ├── IEventBus.ts
    │   │   ├── IEventHandler.ts
    │   │   ├── IEventRegistrar.ts
    │   │   └── IOperationResult.ts
    │   ├── internal
    │   │   ├── deferred.ts
    │   │   └── index.ts
    │   ├── OperationResult.ts
    │   ├── README.md
    │   ├── testing
    │   │   └── createTestEventBus.ts
    │   └── __tests__
    │       └── EventBus.spec.ts
    ├── logging
    │   ├── index.ts
    │   ├── logApi.ts
    │   ├── logBridge.ts
    │   ├── logger.ts
    │   ├── logQuery.ts
    │   ├── logRouteHandler.ts
    │   ├── logStorage.ts
    │   └── README.md
    ├── react-behaviours
    │   ├── BehaviourHost.tsx
    │   ├── BehaviourScheduler.ts
    │   ├── hooks
    │   │   ├── index.ts
    │   │   ├── useBehaviour.ts
    │   │   └── useBehaviourState.ts
    │   ├── index.ts
    │   ├── ReactBehaviour.ts
    │   └── README.md
    └── serialization
        ├── index.ts
        ├── README.md
        ├── Serializable.ts
        └── __tests__
            └── Serializable.spec.ts



--- File: E:\Claim\src\lib\contracts\Implements.ts ---
import {
  assertImplements,
  areRuntimeContractsEnabled,
  type InterfaceSpec,
} from './Interface';

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type AnyConstructor<T extends object = object> = new (...args: any[]) => T;

export const Implements = (name: string, spec: InterfaceSpec) =>
  function <T extends AnyConstructor>(constructor: T): T {
    if (!areRuntimeContractsEnabled()) {
      return constructor;
    }

    const ContractChecked = class extends constructor {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      constructor(...args: any[]) {
        super(...args);
        assertImplements(this, name, spec);
      }
    };

    return ContractChecked as T;
  };




--- File: E:\Claim\src\lib\contracts\index.ts ---
export * from './Interface';
export * from './Implements';



--- File: E:\Claim\src\lib\contracts\Interface.ts ---
export type PrimitiveType =
  | 'string'
  | 'number'
  | 'boolean'
  | 'bigint'
  | 'symbol'
  | 'function'
  | 'object'
  | 'undefined'
  | 'any';

export interface PropertySpecObject {
  type: PrimitiveType;
  optional?: boolean;
  predicate?: (value: unknown) => boolean;
}

export type PropertySpec = PrimitiveType | PropertySpecObject;

export type InterfaceSpec = Record<string, PropertySpec>;

export interface AssertOptions {
  allowMissingOptional?: boolean;
}

const isProductionEnvironment = (): boolean => {
  if (typeof process !== 'undefined' && process.env?.NODE_ENV === 'production') {
    return true;
  }

  const meta = typeof import.meta !== 'undefined' ? (import.meta as { env?: { MODE?: string } }) : undefined;
  if (meta?.env?.MODE === 'production') {
    return true;
  }

  return false;
};

let runtimeContractsEnabled = !isProductionEnvironment();

const normalizeSpec = (spec: PropertySpec): PropertySpecObject => {
  if (typeof spec === 'string') {
    return { type: spec };
  }
  return spec;
};

const isObjectLike = (value: unknown): value is Record<string, unknown> =>
  (typeof value === 'object' || typeof value === 'function') && value !== null;

/**
 * Enables or disables runtime contract enforcement. Contracts are enabled by default in
 * non-production environments and disabled in production builds.
 */
export const setRuntimeContractsEnabled = (enabled: boolean): void => {
  runtimeContractsEnabled = enabled;
};

/**
 * Indicates whether runtime contract validation is currently enabled.
 */
export const areRuntimeContractsEnabled = (): boolean => runtimeContractsEnabled;

/**
 * Composes multiple interface specifications into a single aggregated spec.
 * Later specs take precedence on overlapping property keys.
 */
export const composeInterfaceSpecs = (
  ...specs: InterfaceSpec[]
): InterfaceSpec =>
  specs.reduce<InterfaceSpec>((accumulator, current) => Object.assign(accumulator, current), {});

export const implementsInterface = (
  target: unknown,
  spec: InterfaceSpec
): boolean => {
  if (!isObjectLike(target)) {
    return false;
  }

  return Object.entries(spec).every(([key, descriptor]) => {
    const { type, optional, predicate } = normalizeSpec(descriptor);

    if (!(key in (target as Record<string, unknown>))) {
      return Boolean(optional);
    }

    const value = (target as Record<string, unknown>)[key];

    if (value === undefined) {
      return Boolean(optional);
    }

    if (type === 'any') {
      // no-op
    } else if (type === 'object') {
      if (typeof value !== 'object' || value === null) {
        return false;
      }
    } else if (typeof value !== type) {
      return false;
    }

    if (predicate && !predicate(value)) {
      return false;
    }

    return true;
  });
};

export const assertImplements = (
  target: unknown,
  name: string,
  spec: InterfaceSpec,
  options?: AssertOptions
): void => {
  if (!runtimeContractsEnabled) {
    return;
  }

  if (!isObjectLike(target)) {
    throw new Error(`[${name}] expected object instance, received ${typeof target}`);
  }

  for (const [key, descriptor] of Object.entries(spec)) {
    const { type, optional, predicate } = normalizeSpec(descriptor);
    const hasKey = key in target;

    if (!hasKey) {
      if (optional || options?.allowMissingOptional) {
        continue;
      }
      throw new Error(`[${name}] missing property "${key}"`);
    }

    const value = (target as Record<string, unknown>)[key];

    if (value === undefined) {
      if (optional) {
        continue;
      }
      throw new Error(`[${name}] property "${key}" is undefined`);
    }

    if (type === 'any') {
      // no-op
    } else if (type === 'object') {
      if (typeof value !== 'object' || value === null) {
        throw new Error(
          `[${name}] property "${key}" expected type "object" but received "${typeof value}"`
        );
      }
    } else if (typeof value !== type) {
      throw new Error(
        `[${name}] property "${key}" expected type "${type}" but received "${typeof value}"`
      );
    }

    if (predicate && !predicate(value)) {
      throw new Error(`[${name}] property "${key}" failed custom validation`);
    }
  }
};



--- File: E:\Claim\src\lib\contracts\README.md ---
# Contracts Library

`@lib/contracts` provides lightweight runtime contract checking utilities. They are especially useful during development to ensure objects conform to expected shapes without relying solely on TypeScript’s static analysis. Contracts can be disabled automatically in production builds to avoid runtime overhead.

---

## 1. Overview

| Module       | Purpose                                                                                         |
| ------------ | ----------------------------------------------------------------------------------------------- |
| `Interface.ts` | Define interface specifications and validate / assert objects against them.                    |
| `Implements.ts` | Helper to register interface specs on prototype constructors for later assertion.             |
| `index.ts`   | Re-exports the public API (`assertImplements`, `implementsInterface`, etc.).                    |

---

## 2. Quick Start

### 2.1 Defining an interface specification

```ts
import type { InterfaceSpec } from '@lib/contracts'

export const PlayerContract: InterfaceSpec = {
  id: 'string',
  displayName: 'string',
  chips: {
    type: 'number',
    predicate: (value) => value >= 0,
  },
  metadata: {
    type: 'object',
    optional: true,
  },
}
```

Each property can be either a primitive type string (`'string'`, `'number'`, etc.) or a descriptor object `{ type, optional, predicate }`.

### 2.2 Asserting at runtime

```ts
import { assertImplements } from '@lib/contracts'
import { PlayerContract } from './contracts'

function createPlayer(data: unknown) {
  assertImplements(data, 'Player', PlayerContract)
  // safe to use data as Player here
  return data as Player
}
```

If the object fails validation, `assertImplements` throws with a descriptive error (missing property, wrong type, failed predicate, etc.).

### 2.3 Checking without throwing

```ts
import { implementsInterface } from '@lib/contracts'

if (implementsInterface(candidate, PlayerContract)) {
  // valid
} else {
  // invalid
}
```

`implementsInterface` returns a boolean rather than throwing.

---

## 3. Composing specs

Use `composeInterfaceSpecs` to merge multiple pieces:

```ts
import { composeInterfaceSpecs } from '@lib/contracts'

const BasePlayer = { id: 'string', displayName: 'string' }
const Stats = { gamesPlayed: 'number', wins: 'number' }

export const PlayerWithStats = composeInterfaceSpecs(BasePlayer, Stats)
```

Later specs take precedence for overlapping keys.

---

## 4. Attaching contracts to classes

`Implements.ts` provides a decorator-like helper so you can assert contracts on class instances:

```ts
import { registerInterface } from '@lib/contracts'
import { PlayerContract } from './contracts'

interface Player {
  id: string
  displayName: string
  chips: number
}

class PlayerModel {
  constructor(public readonly state: Player) {}
}

registerInterface(PlayerModel, PlayerContract)
```

Later you can ensure instances implement the contract:

```ts
import { assertRegisteredInterface } from '@lib/contracts'

function ensurePlayer(model: unknown) {
  assertRegisteredInterface(model, 'PlayerModel')
  return model as PlayerModel
}
```

Check `Implements.ts` for additional helpers (listing registered interfaces, etc.).

---

## 5. Enabling / disabling at runtime

By default contracts are **enabled** in non-production environments (based on `process.env.NODE_ENV` or `import.meta.env.MODE`) and disabled in production.

- Force enable/disable at runtime:

```ts
import { setRuntimeContractsEnabled } from '@lib/contracts'

setRuntimeContractsEnabled(false)
```

This is useful for tests or performance-sensitive scenarios.

- To check the current state:

```ts
import { areRuntimeContractsEnabled } from '@lib/contracts'
```

---

## 6. Tips

- Use contracts for untrusted inputs (API responses, local storage) or to guard complex class invariants.
- Remember to wrap assertions in try/catch if you need to recover gracefully.
- Keep specs close to the models they describe (e.g. `src/features/player/contracts.ts`) and import utilities from `@lib/contracts`.

---

Extend this README with additional patterns (async validation, nested specs, etc.) as they emerge.



--- File: E:\Claim\src\lib\core\guid.ts ---
const fallback = () =>
  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0
    const v = c === 'x' ? r : (r & 0x3) | 0x8
    return v.toString(16)
  })

export const createGuid = (): string => {
  if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
    return crypto.randomUUID()
  }

  return fallback()
}



--- File: E:\Claim\src\lib\core\index.ts ---
export { createGuid } from './guid'
export { withTimeout } from './timeout'



--- File: E:\Claim\src\lib\core\timeout.ts ---
export const withTimeout = async <T>(
  promise: Promise<T>,
  timeoutMs: number,
  timeoutMessage?: string
): Promise<T> => {
  if (!Number.isFinite(timeoutMs) || timeoutMs <= 0) {
    return promise
  }

  let timeoutId: ReturnType<typeof setTimeout>

  const timeoutPromise = new Promise<never>((_, reject) => {
    timeoutId = setTimeout(() => {
      reject(new Error(timeoutMessage ?? `Operation timed out after ${timeoutMs}ms`))
    }, timeoutMs)
  })

  try {
    return await Promise.race([promise, timeoutPromise])
  } finally {
    clearTimeout(timeoutId!)
  }
}



--- File: E:\Claim\src\lib\eventing\base\EventArgsBase.ts ---
import { assertImplements } from '@lib/contracts';
import { IEventArgsContract } from '@lib/eventing/contracts/specs';
import type { EventConstructor, IEventArgs } from '@lib/eventing/interfaces/IEventArgs';
import { createGuid } from '@lib/core';

export abstract class EventArgsBase implements IEventArgs {
  public readonly timestamp: number = Date.now();
  public readonly uniqueIdentifier: string = createGuid();
  public isRePublishable = false;

  private disposed = false;

  protected constructor() {
    assertImplements(this, 'IEventArgs', IEventArgsContract);

    const ctor = this.constructor as EventConstructor<IEventArgs>;
    if (!ctor.eventType || typeof ctor.eventType !== 'string') {
      throw new Error(
        `EventArgs subclass "${this.constructor.name}" must declare static readonly eventType.`
      );
    }
  }

  dispose(): void {
    if (this.disposed) {
      return;
    }

    this.disposed = true;
    this.onDispose();
  }

  protected onDispose(): void {
    // Intended for subclasses.
  }

  toString(): string {
    return `${this.constructor.name} [timestamp: ${new Date(
      this.timestamp
    ).toISOString()}, uniqueIdentifier: ${this.uniqueIdentifier}, isRePublishable: ${
      this.isRePublishable
    }]`;
  }
}



--- File: E:\Claim\src\lib\eventing\behaviours\EventBehaviour.ts ---
import { ReactBehaviour } from '@lib/react-behaviours';
import { EventBus } from '@lib/eventing/EventBus';
import type { IEventBus } from '@lib/eventing/interfaces/IEventBus';
import { EventRegistrar } from '@lib/eventing/EventRegistrar';

export interface EventBehaviourContext {
  eventBus: IEventBus;
}

export abstract class EventBehaviour extends ReactBehaviour<EventBehaviourContext> {
  protected readonly eventRegistrar: EventRegistrar;

  protected get eventBus(): IEventBus {
    return this.context?.eventBus ?? EventBus.instance;
  }

  constructor(context: EventBehaviourContext) {
    super(context);
    this.eventRegistrar = new EventRegistrar(this.eventBus);
  }

  protected override onDestroy(): void {
    this.eventRegistrar.dispose();
    super.onDestroy();
  }
}



--- File: E:\Claim\src\lib\eventing\behaviours\EventBehaviourHost.tsx ---
import { useCallback } from 'react';
import type { PropsWithChildren, ReactElement } from 'react';
import { BehaviourHost } from '@lib/react-behaviours';
import { useEventBus } from '@lib/eventing/hooks';
import type { EventBehaviour, EventBehaviourContext } from '@lib/eventing/behaviours';

export interface EventBehaviourHostProps<T extends EventBehaviour> {
  create: (context: EventBehaviourContext) => T;
  onReady?: (behaviour: T) => void;
  autoStart?: boolean;
}

export const EventBehaviourHost = <T extends EventBehaviour>({
  create,
  onReady,
  autoStart,
  children,
}: PropsWithChildren<EventBehaviourHostProps<T>>): ReactElement | null => {
  const eventBus = useEventBus();
  const createWithContext = useCallback(
    () => create({ eventBus }),
    [create, eventBus]
  );
  const handleReady = useCallback(
    (behaviour: EventBehaviour) => {
      onReady?.(behaviour as T);
    },
    [onReady]
  );

  return (
    <BehaviourHost<EventBehaviour, EventBehaviourContext>
      create={createWithContext}
      onReady={handleReady}
      autoStart={autoStart}
    >
      {children ?? null}
    </BehaviourHost>
  );
};



--- File: E:\Claim\src\lib\eventing\behaviours\index.ts ---
export { EventBehaviour } from './EventBehaviour'
export type { EventBehaviourContext } from './EventBehaviour'
export { EventBehaviourHost } from './EventBehaviourHost'
export type { EventBehaviourHostProps } from './EventBehaviourHost'
export { useEventBehaviour } from './useEventBehaviour'
export { useEventBehaviourState } from './useEventBehaviourState'



--- File: E:\Claim\src\lib\eventing\behaviours\README.md ---
# Event Behaviours

`EventBehaviour` lets you encapsulate event-driven logic that can be hosted inside React components. Below is a reference example you can adapt in your own feature code.

```tsx
import { useEventBehaviourState, EventBehaviourHost } from '@lib/eventing/behaviours'
import type { EventBehaviourContext } from '@lib/eventing/behaviours'
import { EventBehaviour } from '@lib/eventing/behaviours'
import { PlayerJoinedEvent, GetLocalPlayerEvent } from '@lib/eventing/events'
import { OperationResult, createOperationDeferred } from '@lib/eventing'

interface PlayerUIBehaviourState {
  player: PlayerProfile | null
  status: 'idle' | 'loading' | 'ready' | 'error'
  error?: string
}

class PlayerUIBehaviour extends EventBehaviour<EventBehaviourContext> {
  private state: PlayerUIBehaviourState = { player: null, status: 'idle' }

  get currentState(): PlayerUIBehaviourState {
    return this.state
  }

  protected awake(): void {
    this.eventRegistrar.subscribe(PlayerJoinedEvent, this.handlePlayerJoined)
    this.eventRegistrar.subscribeAsync(GetLocalPlayerEvent, this.handleGetLocalPlayer)
  }

  protected override onStart(): void {
    void this.requestLocalPlayer()
  }

  private handlePlayerJoined = (event: PlayerJoinedEvent) => {
    this.state = { player: event.player, status: 'ready' }
    this.notifyStateChanged()
  }

  private async handleGetLocalPlayer(event: GetLocalPlayerEvent) {
    if (this.state.player) {
      event.deferred.resolve(OperationResult.success(this.state.player))
      return
    }
    event.deferred.resolve(OperationResult.failure<PlayerProfile>('LOCAL_PLAYER_NOT_AVAILABLE'))
  }

  private async requestLocalPlayer(): Promise<void> {
    this.state = { ...this.state, status: 'loading', error: undefined }
    this.notifyStateChanged()

    const deferred = createOperationDeferred<PlayerProfile>()
    const publishResult = await this.eventBus.publishAsync(new GetLocalPlayerEvent(deferred))

    if (!publishResult.isSuccess || !publishResult.value) {
      this.state = {
        player: null,
        status: 'error',
        error: publishResult.errorMessage ?? 'PLAYER_REQUEST_DISPATCH_FAILED',
      }
      this.notifyStateChanged()
      return
    }

    try {
      const result = await deferred.promise
      if (result.isSuccess && result.value) {
        this.state = { player: result.value, status: 'ready' }
      } else {
        this.state = {
          player: null,
          status: 'error',
          error: result.errorMessage ?? 'UNKNOWN_PLAYER_ERROR',
        }
      }
    } catch (error) {
      this.state = {
        player: null,
        status: 'error',
        error: error instanceof Error ? error.message : 'PLAYER_REQUEST_FAILED',
      }
    } finally {
      this.notifyStateChanged()
    }
  }
}

export const PlayerUIBehaviourComponent = () => {
  const state = useEventBehaviourState(
    context => new PlayerUIBehaviour(context),
    behaviour => behaviour.currentState
  )

  if (state.status === 'loading') return <div>Loading player…</div>
  if (state.status === 'error') return <div>Failed to load player: {state.error}</div>
  if (!state.player) return <div>No player joined yet.</div>

  return <div>Player ready: {state.player.displayName}</div>
}

export const PlayerUIBehaviourHost = () => (
  <EventBehaviourHost
    autoStart
    create={context => new PlayerUIBehaviour(context)}
    onReady={behaviour => {
      // Attach any bootstrapping logic here (e.g. seed data for local previews)
    }}
  />
)
```

For production code, place your own behaviour implementations inside your feature folders rather than under `@lib`. This keeps the library package lean while still conveying the intended usage pattern.



--- File: E:\Claim\src\lib\eventing\behaviours\useEventBehaviour.ts ---
import { useEventBus } from '@lib/eventing/hooks';
import { useBehaviour } from '@lib/react-behaviours';
import type { EventBehaviour, EventBehaviourContext } from '@lib/eventing/behaviours';
import type { UseBehaviourOptions } from '@lib/react-behaviours';

export const useEventBehaviour = <
  T extends EventBehaviour
>(
  factory: (context: EventBehaviourContext) => T,
  options?: UseBehaviourOptions
): T => {
  const eventBus = useEventBus();
  return useBehaviour<T, EventBehaviourContext>(
    context => factory(context ?? { eventBus }),
    { eventBus },
    options
  );
};



--- File: E:\Claim\src\lib\eventing\behaviours\useEventBehaviourState.ts ---
import { useEventBus } from '@lib/eventing/hooks';
import { useBehaviourState } from '@lib/react-behaviours';
import type { EventBehaviour, EventBehaviourContext } from '@lib/eventing/behaviours';

interface UseEventBehaviourStateOptions {
  autoStart?: boolean;
}

export const useEventBehaviourState = <
  T extends EventBehaviour,
  S
>(
  factory: (context: EventBehaviourContext) => T,
  selector: (behaviour: T) => S,
  options?: UseEventBehaviourStateOptions
): S => {
  const eventBus = useEventBus();
  return useBehaviourState<T, S, EventBehaviourContext>(
    context => factory(context ?? { eventBus }),
    selector,
    { eventBus },
    options
  );
};



--- File: E:\Claim\src\lib\eventing\components\EventListener.tsx ---
import type { PropsWithChildren, ReactElement } from 'react';
import type { EventConstructor, IEventArgs } from '@lib/eventing/interfaces/IEventArgs';
import { useEventListener } from '@lib/eventing/hooks';

interface EventListenerProps<T extends IEventArgs> {
  event: EventConstructor<T>;
  handler: (event: T) => void | Promise<void>;
  async?: boolean;
  deps?: ReadonlyArray<unknown>;
}

export const EventListener = <T extends IEventArgs>({
  event,
  handler,
  async = false,
  deps = [],
  children,
}: PropsWithChildren<EventListenerProps<T>>): ReactElement => {
  useEventListener(event, handler, { async, deps });

  return <>{children}</>;
};



--- File: E:\Claim\src\lib\eventing\contracts\specs.ts ---
import type { InterfaceSpec } from '@lib/contracts';

export const IEventHandlerContract: InterfaceSpec = {
  subscribeToEvents: 'function',
  unsubscribeFromEvents: 'function',
};

export const IEventArgsContract: InterfaceSpec = {
  timestamp: { type: 'number' },
  uniqueIdentifier: { type: 'string' },
  isRePublishable: { type: 'boolean' },
  dispose: 'function',
};

export const EventBusContract: InterfaceSpec = {
  subscribe: 'function',
  unsubscribe: 'function',
  publish: 'function',
  subscribeAsync: { type: 'function', optional: true },
  unsubscribeAsync: { type: 'function', optional: true },
  publishAsync: { type: 'function', optional: true },
  clear: 'function',
};

export const IEventRegistrarContract: InterfaceSpec = {
  subscribe: 'function',
  subscribeAsync: 'function',
  unsubscribeAll: 'function',
};

export const IOperationResultContract: InterfaceSpec = {
  isSuccess: { type: 'boolean' },
  value: { type: 'any', optional: true },
  attempts: { type: 'number' },
  errorMessage: { type: 'string', optional: true },
};



--- File: E:\Claim\src\lib\eventing\createEventRegistrar.ts ---
import { EventRegistrar } from './EventRegistrar';
import type { EventConstructor, IEventArgs } from './interfaces/IEventArgs';
import { EventBus } from './EventBus';
import type { IEventBus } from './interfaces/IEventBus';

export interface RegistrarHandle {
  subscribe<T extends IEventArgs>(
    type: EventConstructor<T>,
    handler: (event: T) => void
  ): void;

  subscribeAsync<T extends IEventArgs>(
    type: EventConstructor<T>,
    handler: (event: T) => Promise<void>
  ): void;

  dispose(): void;
}

export const createEventRegistrar = (
  eventBus: IEventBus = EventBus.instance
): RegistrarHandle => {
  const registrar = new EventRegistrar(eventBus);

  return {
    subscribe<T extends IEventArgs>(
      type: EventConstructor<T>,
      handler: (event: T) => void
    ) {
      registrar.subscribe(type, handler);
    },

    subscribeAsync<T extends IEventArgs>(
      type: EventConstructor<T>,
      handler: (event: T) => Promise<void>
    ) {
      registrar.subscribeAsync(type, handler);
    },

    dispose() {
      registrar.dispose();
    },
  };
};



--- File: E:\Claim\src\lib\eventing\EventBus.ts ---
import type { EventConstructor, IEventArgs } from './interfaces/IEventArgs';
import type { IEventBus } from './interfaces/IEventBus';
import type { ModuleLogger } from '@lib/logging';
import { defaultEventLogger } from './eventLogger';
import { OperationResult } from './OperationResult';
import { withTimeout } from '@lib/core';

type SyncHandler<T extends IEventArgs> = (eventArgs: T) => void;
type AsyncHandler<T extends IEventArgs> = (eventArgs: T) => Promise<void>;

interface QueuedEvent<T extends IEventArgs> {
  event: T;
  attempts: number;
  enqueuedAt: number;
}

export interface EventBusOptions {
  queueBatchSize: number;
  maxRetryAttempts: number;
  queueTimeoutMs: number;
  maxQueuedEvents: number;
  eventTtlMs: number;
  asyncTimeoutMs: number;
}

const DEFAULT_OPTIONS: EventBusOptions = {
  queueBatchSize: 10,
  maxRetryAttempts: 5,
  queueTimeoutMs: 5000,
  maxQueuedEvents: 1000,
  eventTtlMs: 60_000,
  asyncTimeoutMs: 10_000,
};

const scheduleMicrotask =
  typeof queueMicrotask === 'function'
    ? queueMicrotask
    : (callback: () => void) => {
        void Promise.resolve().then(callback);
      };

export class EventBus implements IEventBus {
  private static _instance: EventBus | null = null;

  static get instance(): EventBus {
    if (!EventBus._instance) {
      EventBus._instance = new EventBus();
    }
    return EventBus._instance;
  }

  static configure(instance: EventBus): void {
    EventBus._instance = instance;
  }

  private readonly subscribers = new Map<string, Array<SyncHandler<IEventArgs>>>();
  private readonly asyncSubscribers = new Map<string, Array<AsyncHandler<IEventArgs>>>();
  private readonly queuedEvents = new Map<string, Array<QueuedEvent<IEventArgs>>>();
  private readonly inFlightEvents = new Map<string, number>();
  private readonly processingQueues = new Set<string>();
  private readonly missingEventTypeWarned = new Set<string>();
  private readonly options: EventBusOptions;
  private readonly logger: ModuleLogger;

  constructor(
    options: EventBusOptions = DEFAULT_OPTIONS,
    logger: ModuleLogger = defaultEventLogger
  ) {
    this.options = options;
    this.logger = logger;
  }

  /**
   * Register a synchronous subscriber for the specified event type.
   * @param type The event constructor to subscribe to.
   * @param handler Callback invoked when the event is raised.
   * @param force When true, duplicate handlers are allowed.
   */
  subscribe<T extends IEventArgs>(
    type: EventConstructor<T>,
    handler: SyncHandler<T>,
    force = false
  ): void {
    const key = this.getKey(type);
    const subscriptionList = this.subscribers.get(key) ?? [];

    if (force || !subscriptionList.includes(handler as SyncHandler<IEventArgs>)) {
      subscriptionList.push(handler as SyncHandler<IEventArgs>);
      this.subscribers.set(key, subscriptionList);
    }

    void this.processQueuedEvents(type);
  }

  /**
   * Register an asynchronous subscriber for the specified event type.
   * When {@link publishAsync} is awaited, subscribers are invoked sequentially in registration order.
   *
   * @param type The event constructor to subscribe to.
   * @param handler Async callback invoked when the event is raised.
   * @param force When true, duplicate handlers are allowed.
   */
  subscribeAsync<T extends IEventArgs>(
    type: EventConstructor<T>,
    handler: AsyncHandler<T>,
    force = false
  ): void {
    const key = this.getKey(type);
    const subscriptionList = this.asyncSubscribers.get(key) ?? [];

    if (force || !subscriptionList.includes(handler as AsyncHandler<IEventArgs>)) {
      subscriptionList.push(handler as AsyncHandler<IEventArgs>);
      this.asyncSubscribers.set(key, subscriptionList);
    }

    void this.processQueuedEvents(type);
  }

  unsubscribe<T extends IEventArgs>(type: EventConstructor<T>, handler: SyncHandler<T>): void {
    const key = this.getKey(type);
    const subscriptionList = this.subscribers.get(key);
    if (!subscriptionList?.length) {
      return;
    }

    const filtered = subscriptionList.filter(existing => existing !== handler);
    if (filtered.length) {
      this.subscribers.set(key, filtered);
    } else {
      this.subscribers.delete(key);
    }
  }

  unsubscribeAsync<T extends IEventArgs>(type: EventConstructor<T>, handler: AsyncHandler<T>): void {
    const key = this.getKey(type);
    const subscriptionList = this.asyncSubscribers.get(key);
    if (!subscriptionList?.length) {
      return;
    }

    const filtered = subscriptionList.filter(existing => existing !== handler);
    if (filtered.length) {
      this.asyncSubscribers.set(key, filtered);
    } else {
      this.asyncSubscribers.delete(key);
    }
  }

  /**
   * Publish an event and await synchronous subscribers. When `awaitAsync` is set to `true`,
   * asynchronous subscribers are also awaited sequentially, providing deterministic delivery order.
   *
   * @param eventArgs Event payload to publish.
   * @param options Optional publish flags.
   * @returns An {@link OperationResult} indicating whether any subscriber handled the event.
   */
  async publish<T extends IEventArgs>(
    eventArgs: T,
    options: { awaitAsync?: boolean; force?: boolean } = {}
  ): Promise<OperationResult<boolean>> {
    const { awaitAsync = false, force = false } = options;
    try {
      const handled = await this.guardAndPublish(eventArgs, awaitAsync, force, true);
      return OperationResult.success(handled);
    } catch (error) {
      const message =
        error instanceof Error ? error.message : `Failed to publish ${eventArgs.constructor.name}`;
      this.logger.logError(`Error publishing event ${eventArgs.constructor.name}`, error);
      return OperationResult.failure(message);
    }
  }

  /**
   * Publish an event and await all asynchronous subscribers sequentially.
   * A timeout may be provided to guard against hung handlers.
   *
   * @param eventArgs Event payload to publish.
   * @param options Optional publish configuration.
   * @returns An {@link OperationResult} that resolves when async handlers complete or timeout.
   */
  publishAsync<T extends IEventArgs>(
    eventArgs: T,
    options: { force?: boolean; timeoutMs?: number } = {}
  ): Promise<OperationResult<boolean>> {
    const timeout = options.timeoutMs ?? this.options.asyncTimeoutMs;
    return withTimeout(
      this.publish(eventArgs, { awaitAsync: true, force: options.force ?? false }),
      timeout,
      `Timed out awaiting async subscribers for ${eventArgs.constructor.name}`
    ).catch(error => {
      const message =
        error instanceof Error ? error.message : `Failed to publish ${eventArgs.constructor.name}`;
      this.logger.logError(message, error);
      return OperationResult.failure(message);
    });
  }

  /**
   * Remove all registered subscribers and queued events from the bus.
   */
  clear(): void {
    if (
      this.subscribers.size ||
      this.asyncSubscribers.size ||
      this.queuedEvents.size
    ) {
      this.logger.logWarning(
        'EventBus is being cleared. All current subscribers and queued events will be removed.'
      );
    }

    this.subscribers.clear();
    this.asyncSubscribers.clear();
    this.queuedEvents.clear();
    this.inFlightEvents.clear();
    this.processingQueues.clear();
  }

  private getKey(type: EventConstructor<IEventArgs>): string {
    if (type.eventType) {
      return type.eventType;
    }
    const fallback = type.name;
    if (!this.missingEventTypeWarned.has(fallback)) {
      this.logger.logWarning(
        `Event constructor "${fallback}" is missing static eventType; falling back to constructor.name.`
      );
      this.missingEventTypeWarned.add(fallback);
    }
    return fallback;
  }

  private async guardAndPublish<T extends IEventArgs>(
    eventArgs: T,
    awaitAsyncSubscribers: boolean,
    force: boolean,
    allowQueue: boolean
  ): Promise<boolean> {
    const eventType = this.getKey(eventArgs.constructor as EventConstructor<IEventArgs>);

    if (!force && !eventArgs.isRePublishable && this.inFlightEvents.has(eventArgs.uniqueIdentifier)) {
      return false;
    }

    this.incrementInFlight(eventArgs.uniqueIdentifier);

    try {
      const handled = await this.handlePublishAction(eventArgs, awaitAsyncSubscribers);

      if (!handled && allowQueue) {
        const queued = await this.queueEvent(eventArgs);
        if (queued) {
          this.logger.logWarning(
            `Event of type ${eventType} was published but no subscribers handled it. Queued for later processing.`
          );
        } else {
          eventArgs.dispose();
          this.logger.logError(`Failed to queue event of type ${eventType}.`);
        }
      } else {
        eventArgs.dispose();
      }

      return handled;
    } catch (error) {
      this.logger.logError(`Error in publish for event type ${eventType}`, error);
      throw error;
    } finally {
      this.decrementInFlight(eventArgs.uniqueIdentifier);
    }
  }

  private async handlePublishAction<T extends IEventArgs>(
    eventArgs: T,
    awaitAsyncSubscribers: boolean
  ): Promise<boolean> {
    const key = this.getKey(eventArgs.constructor as EventConstructor<IEventArgs>);
    let handled = false;

    const syncSubscribers = this.subscribers.get(key);
    if (syncSubscribers?.length) {
      for (const subscriber of [...syncSubscribers]) {
        try {
          (subscriber as SyncHandler<T>)(eventArgs);
        } catch (error) {
          this.logger.logError(
            `Error in subscriber for event type ${key}: ${(error as Error)?.message ?? error}`,
            error
          );
          throw error;
        }
      }
      handled = true;
    }

    const asyncSubscribers = this.asyncSubscribers.get(key);
    if (asyncSubscribers?.length) {
      handled = true;
      if (awaitAsyncSubscribers) {
        for (const subscriber of [...asyncSubscribers]) {
          await this.invokeAsyncSubscriber(subscriber as AsyncHandler<T>, eventArgs, key, true);
        }
      } else {
        for (const subscriber of [...asyncSubscribers]) {
          scheduleMicrotask(() => {
            void this.invokeAsyncSubscriber(subscriber as AsyncHandler<T>, eventArgs, key, false);
          });
        }
      }
    }

    return handled;
  }

  private async invokeAsyncSubscriber<T extends IEventArgs>(
    subscriber: AsyncHandler<T>,
    eventArgs: T,
    key: string,
    enforceTimeout: boolean
  ): Promise<void> {
    const execute = async () => {
      const result = subscriber(eventArgs);
      if (enforceTimeout) {
        await withTimeout(
          result,
          this.options.asyncTimeoutMs,
          `Async subscriber timeout for event type ${key}`
        );
      } else {
        await result;
      }
    };

    try {
      await execute();
    } catch (error) {
      this.logger.logError(
        `Error in async subscriber for event type ${key}: ${(error as Error)?.message ?? error}`,
        error
      );
      throw error;
    }
  }

  private async queueEvent<T extends IEventArgs>(eventArgs: T): Promise<boolean> {
    try {
      const key = this.getKey(eventArgs.constructor as EventConstructor<IEventArgs>);
      const queue = this.queuedEvents.get(key) ?? [];

      if (queue.length >= this.options.maxQueuedEvents) {
        const dropped = queue.shift();
        if (dropped) {
          dropped.event.dispose();
          this.logger.logWarning(
            `Queue for ${key} reached capacity (${this.options.maxQueuedEvents}). Dropping oldest event.`
          );
        }
      }

      queue.push({ event: eventArgs, attempts: 0, enqueuedAt: Date.now() });
      this.queuedEvents.set(key, queue);

      await Promise.resolve();
      return true;
    } catch (error) {
      this.logger.logError(
        `Queue event failed for ${this.getKey(eventArgs.constructor as EventConstructor<IEventArgs>)}: ${
          (error as Error)?.message ?? error
        }`,
        error
      );
      return false;
    }
  }

  private async processQueuedEvents<T extends IEventArgs>(type: EventConstructor<T>): Promise<void> {
    const key = this.getKey(type as unknown as EventConstructor<IEventArgs>);
    const queue = this.queuedEvents.get(key);

    if (!queue?.length || this.processingQueues.has(key)) {
      return;
    }

    this.processingQueues.add(key);

    try {
      const remaining: Array<QueuedEvent<IEventArgs>> = [];

      while (queue.length) {
        const batch = queue.splice(0, this.options.queueBatchSize);
        for (const queued of batch) {
          if (this.isExpired(queued)) {
            queued.event.dispose();
            this.logger.logWarning(`Dropping expired event of type ${key} from queue.`);
            continue;
          }

          try {
            const handled = await withTimeout(
              this.guardAndPublish(queued.event as T, true, true, false),
              this.options.queueTimeoutMs,
              `Timeout occurred while processing queued event type ${key}`
            );

            if (handled) {
              queued.event.dispose();
            } else {
              this.requeueIfPossible(queued, remaining, key);
            }
          } catch (error) {
            this.logger.logError(
              `Error during queued event processing for ${key}: ${(error as Error)?.message ?? error}`,
              error
            );
            this.requeueIfPossible(queued, remaining, key);
          } finally {
            // guardAndPublish will balance in-flight tracking
          }
        }

        await Promise.resolve();
      }

      if (remaining.length) {
        this.queuedEvents.set(key, remaining);
      } else {
        this.queuedEvents.delete(key);
      }
    } finally {
      this.processingQueues.delete(key);
    }
  }

  private requeueIfPossible(
    queuedEvent: QueuedEvent<IEventArgs>,
    failedQueue: Array<QueuedEvent<IEventArgs>>,
    key: string
  ): void {
    const nextAttempt = queuedEvent.attempts + 1;

    if (nextAttempt <= this.options.maxRetryAttempts) {
      failedQueue.push({
        event: queuedEvent.event,
        attempts: nextAttempt,
        enqueuedAt: queuedEvent.enqueuedAt,
      });
    } else {
      queuedEvent.event.dispose();
      this.logger.logWarning(`Event ${key} has exceeded maximum retry attempts and will be dropped.`);
    }
  }

  private isExpired(queuedEvent: QueuedEvent<IEventArgs>): boolean {
    return Date.now() - queuedEvent.enqueuedAt > this.options.eventTtlMs;
  }

  private incrementInFlight(eventId: string): void {
    const current = this.inFlightEvents.get(eventId) ?? 0;
    this.inFlightEvents.set(eventId, current + 1);
  }

  private decrementInFlight(eventId: string): void {
    const current = this.inFlightEvents.get(eventId);
    if (current === undefined) {
      return;
    }

    if (current <= 1) {
      this.inFlightEvents.delete(eventId);
    } else {
      this.inFlightEvents.set(eventId, current - 1);
    }
  }
}



--- File: E:\Claim\src\lib\eventing\eventLogger.ts ---
import { createModuleLogger, type ModuleLogger, type LogModule } from '@lib/logging'

const DEFAULT_PREFIX = '[EventBus]'
const DEFAULT_MODULE: LogModule = 'GAME_ENGINE'

export const createEventLogger = (
  module: LogModule = DEFAULT_MODULE,
  prefix: string = DEFAULT_PREFIX
): ModuleLogger => createModuleLogger(module, { prefix })

export const defaultEventLogger: ModuleLogger = createEventLogger()



--- File: E:\Claim\src\lib\eventing\EventRegistrar.ts ---
import type { IEventRegistrar } from './interfaces/IEventRegistrar';
import { EventBus } from './EventBus';
import type { EventConstructor, IEventArgs } from './interfaces/IEventArgs';
import type { IEventBus } from './interfaces/IEventBus';
import { assertImplements } from '@lib/contracts';
import { EventBusContract, IEventRegistrarContract } from '@lib/eventing/contracts/specs';
import { createEventLogger } from './eventLogger';

interface EventRegistrarBase<T extends IEventArgs> {
  readonly type: EventConstructor<T>;
  equals(other: EventRegistrarBase<IEventArgs>): boolean;
  unsubscribe(eventBus: IEventBus): void;
}

class EventRegistrarSync<T extends IEventArgs> implements EventRegistrarBase<T> {
  readonly type: EventConstructor<T>;
  readonly handler: (event: T) => void;

  constructor(type: EventConstructor<T>, handler: (event: T) => void) {
    this.type = type;
    this.handler = handler;
  }

  unsubscribe(eventBus: IEventBus): void {
    eventBus.unsubscribe(this.type, this.handler);
  }

  equals(other: EventRegistrarBase<IEventArgs>): boolean {
    if (other instanceof EventRegistrarSync) {
      return this.handler === other.handler && this.type === other.type;
    }

    return false;
  }
}

class EventRegistrarAsync<T extends IEventArgs> implements EventRegistrarBase<T> {
  readonly type: EventConstructor<T>;
  readonly handler: (event: T) => Promise<void>;

  constructor(type: EventConstructor<T>, handler: (event: T) => Promise<void>) {
    this.type = type;
    this.handler = handler;
  }

  unsubscribe(eventBus: IEventBus): void {
    eventBus.unsubscribeAsync(this.type, this.handler);
  }

  equals(other: EventRegistrarBase<IEventArgs>): boolean {
    if (other instanceof EventRegistrarAsync) {
      return this.handler === other.handler && this.type === other.type;
    }

    return false;
  }
}

type RegistrarEntry =
  | EventRegistrarSync<IEventArgs>
  | EventRegistrarAsync<IEventArgs>;

export class EventRegistrar implements IEventRegistrar {
  private readonly subscriptions = new Map<RegistrarEntry, true>();
  private disposed = false;
  private readonly eventBus: IEventBus;
  private readonly logger = createEventLogger('GAME_ENGINE');

  constructor(eventBus: IEventBus = EventBus.instance) {
    assertImplements(this, 'IEventRegistrar', IEventRegistrarContract);
    assertImplements(eventBus, 'EventBus', EventBusContract);
    this.eventBus = eventBus;
  }

  subscribe<T extends IEventArgs>(
    type: EventConstructor<T>,
    handler: (event: T) => void
  ): void {
    if (this.disposed) {
      return;
    }

    if (!handler) {
      return;
    }

    const entry = new EventRegistrarSync(type, handler);
    if (!this.hasEntry(entry)) {
      this.subscriptions.set(
        entry as unknown as RegistrarEntry,
        true
      );
      this.eventBus.subscribe(type, handler);
    }
  }

  subscribeAsync<T extends IEventArgs>(
    type: EventConstructor<T>,
    handler: (event: T) => Promise<void>
  ): void {
    if (this.disposed) {
      return;
    }

    if (!handler) {
      return;
    }

    const entry = new EventRegistrarAsync(type, handler);
    if (!this.hasEntry(entry)) {
      this.subscriptions.set(entry as unknown as RegistrarEntry, true);
      this.eventBus.subscribeAsync(type, handler);
    }
  }

  unsubscribeAll(): void {
    for (const entry of this.subscriptions.keys()) {
      try {
        entry.unsubscribe(this.eventBus);
      } catch (error) {
        const typeName = (entry as EventRegistrarSync<IEventArgs>).type?.name ?? 'Unknown';
        this.logger.logError(
          `[EventRegistrar] Failed to unsubscribe event of type ${typeName}`,
          error
        );
      }
    }

    this.subscriptions.clear();
  }

  dispose(): void {
    if (this.disposed) {
      return;
    }

    this.unsubscribeAll();
    this.disposed = true;
  }

  private hasEntry(entry: EventRegistrarBase<IEventArgs>): boolean {
    for (const existing of this.subscriptions.keys()) {
      if (
        existing instanceof EventRegistrarSync &&
        existing.equals(entry)
      ) {
        return true;
      }

      if (
        existing instanceof EventRegistrarAsync &&
        existing.equals(entry)
      ) {
        return true;
      }
    }

    return false;
  }
}



--- File: E:\Claim\src\lib\eventing\events\GetLocalPlayerEvent.ts ---
import { EventArgsBase } from '@lib/eventing/base/EventArgsBase';
import type { OperationDeferred } from '@lib/eventing/internal';
import type { PlayerProfile } from './PlayerTypes';

export class GetLocalPlayerEvent extends EventArgsBase {
  static readonly eventType = 'GetLocalPlayerEvent';

  public readonly deferred: OperationDeferred<PlayerProfile>;

  constructor(deferred: OperationDeferred<PlayerProfile>) {
    super();
    this.deferred = deferred;
  }
}



--- File: E:\Claim\src\lib\eventing\events\index.ts ---
export * from './PlayerTypes';
export * from './PlayerJoinedEvent';
export * from './GetLocalPlayerEvent';



--- File: E:\Claim\src\lib\eventing\events\PlayerJoinedEvent.ts ---
import { EventArgsBase } from '@lib/eventing/base/EventArgsBase';
import type { PlayerProfile } from './PlayerTypes';

export class PlayerJoinedEvent extends EventArgsBase {
  static readonly eventType = 'PlayerJoinedEvent';

  public readonly player: PlayerProfile;

  constructor(player: PlayerProfile) {
    super();
    this.player = player;
  }
}



--- File: E:\Claim\src\lib\eventing\events\PlayerTypes.ts ---
export interface PlayerProfile {
  id: string;
  displayName: string;
  avatarUrl?: string;
  metadata?: Record<string, unknown>;
}



--- File: E:\Claim\src\lib\eventing\hooks\EventBusContext.ts ---
import { createContext } from 'react';
import type { IEventBus } from '@lib/eventing/interfaces/IEventBus';
import { EventBus } from '@lib/eventing/EventBus';

export const EventBusContext = createContext<IEventBus | null>(null);



--- File: E:\Claim\src\lib\eventing\hooks\EventBusProvider.tsx ---
import type { PropsWithChildren } from 'react';
import type { IEventBus } from '@lib/eventing/interfaces/IEventBus';
import { EventBus } from '@lib/eventing/EventBus';
import { EventBusContext } from './EventBusContext';

interface EventBusProviderProps {
  value?: IEventBus;
}

export const EventBusProvider = ({
  value,
  children,
}: PropsWithChildren<EventBusProviderProps>) => {
  const bus = value ?? EventBus.instance;
  return (
    <EventBusContext.Provider value={bus}>{children}</EventBusContext.Provider>
  );
};



--- File: E:\Claim\src\lib\eventing\hooks\index.ts ---
export { EventBusContext } from './EventBusContext'
export { EventBusProvider } from './EventBusProvider'
export { useEventBus } from './useEventBus'
export { useEventListener } from './useEventListener'
export { useEventRegistrar } from './useEventRegistrar'



--- File: E:\Claim\src\lib\eventing\hooks\useEventBus.ts ---
import { useContext } from 'react';
import type { IEventBus } from '@lib/eventing/interfaces/IEventBus';
import { EventBus } from '@lib/eventing/EventBus';
import { EventBusContext } from './EventBusContext';

export const useEventBus = (): IEventBus => {
  const bus = useContext(EventBusContext);
  return bus ?? EventBus.instance;
};



--- File: E:\Claim\src\lib\eventing\hooks\useEventListener.ts ---
import type { DependencyList } from 'react';
import type { EventConstructor, IEventArgs } from '@lib/eventing/interfaces/IEventArgs';
import { useEventRegistrar } from './useEventRegistrar';

interface EventListenerOptions {
  async?: boolean;
  deps?: DependencyList;
}

export const useEventListener = <T extends IEventArgs>(
  eventType: EventConstructor<T>,
  handler: (event: T) => void | Promise<void>,
  options?: EventListenerOptions
): void => {
  const isAsync = options?.async ?? false;
  const deps = options?.deps ?? [];

  useEventRegistrar(
    registrar => {
      if (isAsync) {
        registrar.subscribeAsync(eventType, handler as (event: T) => Promise<void>);
      } else {
        registrar.subscribe(eventType, handler as (event: T) => void);
      }

      return undefined;
    },
    [eventType, handler, isAsync, ...deps]
  );
};



--- File: E:\Claim\src\lib\eventing\hooks\useEventRegistrar.ts ---
import type { DependencyList } from 'react';
import { useEffect } from 'react';
import { EventRegistrar } from '@lib/eventing/EventRegistrar';
import { useEventBus } from './useEventBus';

type Cleanup = void | (() => void | Promise<void>);

export type EventRegistrarEffect = (registrar: EventRegistrar) => Cleanup;

export const useEventRegistrar = (
  effect: EventRegistrarEffect,
  deps: DependencyList = []
): void => {
  const eventBus = useEventBus();

  useEffect(() => {
    const registrar = new EventRegistrar(eventBus);
    const cleanup = effect(registrar);

    return () => {
      if (typeof cleanup === 'function') {
        const result = cleanup();
        if (result instanceof Promise) {
          void result;
        }
      }
      registrar.dispose();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [eventBus, ...deps]);
};



--- File: E:\Claim\src\lib\eventing\index.ts ---
export * from './EventBus';
export * from './EventRegistrar';
export * from './OperationResult';
export * from './createEventRegistrar';
export * from './interfaces/IEventArgs';
export * from './interfaces/IEventBus';
export * from './interfaces/IEventHandler';
export * from './interfaces/IEventRegistrar';
export * from './events';
export * from './behaviours';
export * from './hooks';
export * from './eventLogger';
export {
  createDeferred,
  createOperationDeferred,
  type Deferred,
  type OperationDeferred,
} from './internal';



--- File: E:\Claim\src\lib\eventing\interfaces\IEventArgs.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */

export interface IEventArgs {
  /**
   * UTC timestamp in milliseconds.
   */
  readonly timestamp: number;

  /**
   * Unique identifier for the event instance (GUID).
   */
  readonly uniqueIdentifier: string;

  /**
   * When true, the event can be published repeatedly without being filtered.
   */
  isRePublishable: boolean;

  /**
   * Dispose any resource held by the event args.
   */
  dispose(): void;
}

export interface EventTypeDescriptor {
  readonly eventType: string;
}

export type EventConstructor<T extends IEventArgs> = {
  new (...args: any[]): T;
} & EventTypeDescriptor;



--- File: E:\Claim\src\lib\eventing\interfaces\IEventBus.ts ---
import type { OperationResult } from '@lib/eventing/OperationResult';
import type { EventConstructor, IEventArgs } from '@lib/eventing/interfaces/IEventArgs';

export interface PublishOptions {
  awaitAsync?: boolean;
  force?: boolean;
}

export interface IEventBus {
  subscribe<T extends IEventArgs>(
    type: EventConstructor<T>,
    handler: (event: T) => void,
    force?: boolean
  ): void;

  subscribeAsync<T extends IEventArgs>(
    type: EventConstructor<T>,
    handler: (event: T) => Promise<void>,
    force?: boolean
  ): void;

  unsubscribe<T extends IEventArgs>(
    type: EventConstructor<T>,
    handler: (event: T) => void
  ): void;

  unsubscribeAsync<T extends IEventArgs>(
    type: EventConstructor<T>,
    handler: (event: T) => Promise<void>
  ): void;

  publish<T extends IEventArgs>(
    eventArgs: T,
    options?: PublishOptions
  ): Promise<OperationResult<boolean>>;

  publishAsync<T extends IEventArgs>(
    eventArgs: T,
    options?: { force?: boolean; timeoutMs?: number }
  ): Promise<OperationResult<boolean>>;

  clear(): void;
}




--- File: E:\Claim\src\lib\eventing\interfaces\IEventHandler.ts ---
import type { IEventRegistrar } from './IEventRegistrar';

export interface IEventHandler {
  eventRegistrar: IEventRegistrar;
  subscribeToEvents(): void;
  unsubscribeFromEvents(): void;
}



--- File: E:\Claim\src\lib\eventing\interfaces\IEventRegistrar.ts ---
import type { EventConstructor, IEventArgs } from './IEventArgs';

export interface IEventRegistrar {
  subscribe<T extends IEventArgs>(
    type: EventConstructor<T>,
    handler: (args: T) => void
  ): void;

  subscribeAsync<T extends IEventArgs>(
    type: EventConstructor<T>,
    handler: (args: T) => Promise<void>
  ): void;

  unsubscribeAll(): void;
}



--- File: E:\Claim\src\lib\eventing\interfaces\IOperationResult.ts ---
export interface IOperationResult<T> {
  readonly isSuccess: boolean;
  readonly value: T | undefined;
  readonly errorMessage?: string;
  readonly attempts: number;
}



--- File: E:\Claim\src\lib\eventing\internal\deferred.ts ---
import { OperationResult } from '../OperationResult'

export interface Deferred<T> {
  promise: Promise<T>
  resolve(value: T): void
  reject(reason?: unknown): void
}

export interface OperationDeferred<T> {
  promise: Promise<OperationResult<T>>
  resolve(result: OperationResult<T>): void
  reject(reason?: unknown): void
}

export const createDeferred = <T>(): Deferred<T> => {
  let resolve!: (value: T) => void
  let reject!: (reason?: unknown) => void

  const promise = new Promise<T>((res, rej) => {
    resolve = res
    reject = rej
  })

  return {
    promise,
    resolve(value: T) {
      resolve(value)
    },
    reject(reason?: unknown) {
      reject(reason)
    },
  }
}

export const createOperationDeferred = <T>(): OperationDeferred<T> => {
  let resolve!: (value: OperationResult<T>) => void
  let reject!: (reason?: unknown) => void

  const promise = new Promise<OperationResult<T>>((res, rej) => {
    resolve = res
    reject = rej
  })

  return {
    promise,
    resolve(result: OperationResult<T>) {
      resolve(result)
    },
    reject(reason?: unknown) {
      reject(reason)
    },
  }
}



--- File: E:\Claim\src\lib\eventing\internal\index.ts ---
export {
  createDeferred,
  createOperationDeferred,
  type Deferred,
  type OperationDeferred,
} from './deferred'



--- File: E:\Claim\src\lib\eventing\OperationResult.ts ---
import type { IOperationResult } from '@lib/eventing/interfaces/IOperationResult';
import { defaultEventLogger } from './eventLogger';
import { assertImplements } from '@lib/contracts';
import { IOperationResultContract } from '@lib/eventing/contracts/specs';

export class OperationResult<T> implements IOperationResult<T> {
  public readonly isSuccess: boolean;
  public readonly value: T | undefined;
  public readonly attempts: number;
  public readonly errorMessage?: string;

  private constructor(
    isSuccess: boolean,
    value: T | undefined,
    attempts = 0,
    errorMessage?: string
  ) {
    this.isSuccess = isSuccess;
    this.value = value;
    this.attempts = attempts;
    this.errorMessage = errorMessage;

    assertImplements(this, 'IOperationResult', IOperationResultContract);
  }

  static success<T>(value: T, attempts = 0): OperationResult<T> {
    return new OperationResult<T>(true, value, attempts);
  }

  static failure<T>(errorMessage: string, attempts = 0): OperationResult<T> {
    defaultEventLogger.logError(errorMessage);
    return new OperationResult<T>(false, undefined, attempts, errorMessage);
  }
}



--- File: E:\Claim\src\lib\eventing\README.md ---
# Eventing Library

The `@lib/eventing` package provides the runtime for message–driven communication in the app.  
It contains:

- `EventBus` – central hub for publishing and subscribing to events
- Event contracts (`EventArgsBase`, interfaces) – strongly typed payloads
- `EventRegistrar` – utility for registering/unregistering listeners with lifetime management
- React bindings (`EventBusProvider`, hooks, behaviours)
- Helpers (`createDeferred`, `createEventRegistrar`, etc.)

This document explains how to use those pieces together with practical examples.

---

## 1. Getting Started

### 1.1 Creating an Event

All events extend `EventArgsBase`. Provide a static `eventType` and any payload fields you need.

```ts
import { EventArgsBase } from '@lib/eventing'

export interface PlayerJoinedPayload {
  playerId: string
  displayName: string
}

export class PlayerJoinedEvent extends EventArgsBase {
  static readonly eventType = 'PlayerJoinedEvent'

  constructor(public readonly payload: PlayerJoinedPayload) {
    super()
    this.isRePublishable = false // optional; default false
  }
}
```

### 1.2 Registering the Event Bus in React

Wrap the part of the tree that needs events with `EventBusProvider`.  
By default it uses the singleton bus (`EventBus.instance`), but you can inject your own instance.

```tsx
import { EventBusProvider } from '@lib/eventing/hooks/EventBusProvider'

export function App() {
  return (
    <EventBusProvider>
      {/* the rest of your app */}
    </EventBusProvider>
  )
}
```

---

## 2. Subscribing to Events

### 2.1 Using the Registrar (recommended in non-React code)

```ts
import { EventRegistrar, createEventRegistrar } from '@lib/eventing'
import { PlayerJoinedEvent } from './PlayerJoinedEvent'

const registrar: EventRegistrar = createEventRegistrar()

registrar.subscribe(PlayerJoinedEvent, (event) => {
  console.log('Player joined', event.payload)
})

// Later, when you no longer need the subscriptions:
registrar.dispose()
```

`createEventRegistrar` automatically points to the singleton bus.  
If you need a custom bus instance (e.g., for tests), instantiate `new EventRegistrar(customBus)`.

### 2.2 Hooks inside React

```tsx
import { useEventListener } from '@lib/eventing/hooks'
import { PlayerJoinedEvent } from './PlayerJoinedEvent'

export function PlayerToast() {
  useEventListener(PlayerJoinedEvent, ({ payload }) => {
    // show toast, update state, etc.
  })

  return null
}
```

The hook automatically subscribes on mount and unsubscribes on unmount.

### 2.3 Event Behaviours (stateful React wrappers)

See `./behaviours/README.md` for a deep dive. Behaviours are best when you need:

- Internal lifecycle (`awake`, `onStart`, `onDestroy`)
- Polling or scheduled updates (`startUpdateLoop`)
- React state binding via `useEventBehaviour` / `useEventBehaviourState`

---

## 3. Publishing Events

```ts
import { EventBus, OperationResult } from '@lib/eventing'
import { PlayerJoinedEvent } from './PlayerJoinedEvent'

const bus = EventBus.instance

async function notifyPlayerJoin(payload: PlayerJoinedPayload): Promise<OperationResult<boolean>> {
  return bus.publish(new PlayerJoinedEvent(payload))
}
```

`publish` waits for synchronous subscribers. To wait for async subscribers, use `publishAsync`.

```ts
const result = await bus.publishAsync(new PlayerJoinedEvent(payload), {
  timeoutMs: 5000, // optional custom timeout (defaults to 10s)
})

if (!result.isSuccess) {
  console.error(result.errorMessage)
}
```

---

## 4. Request/Response Patterns

Sometimes you need to broadcast a request and await a response.  
Use `createOperationDeferred` to bundle a promise with the event.

### 4.1 Event Definition

```ts
import { EventArgsBase, createOperationDeferred, type OperationDeferred } from '@lib/eventing'
import type { PlayerProfile } from './types'

export class GetLocalPlayerEvent extends EventArgsBase {
  static readonly eventType = 'GetLocalPlayerEvent'
  constructor(public readonly deferred: OperationDeferred<PlayerProfile>) {
    super()
  }
}
```

### 4.2 Publishing and Awaiting

```ts
const deferred = createOperationDeferred<PlayerProfile>()

const publishResult = await bus.publishAsync(new GetLocalPlayerEvent(deferred))
if (!publishResult.isSuccess) {
  // no listeners handled the request
  return null
}

const result = await deferred.promise
if (result.isSuccess) {
  return result.value
}

throw new Error(result.errorMessage ?? 'Unknown player error')
```

### 4.3 Handling the Request

```ts
registrar.subscribeAsync(GetLocalPlayerEvent, async (event) => {
  try {
    const player = await loadPlayer()
    event.deferred.resolve(OperationResult.success(player))
  } catch (error) {
    event.deferred.resolve(
      OperationResult.failure(error instanceof Error ? error.message : 'PLAYER_LOOKUP_FAILED')
    )
  }
})
```

---

## 5. Awaiting Multiple Subscribers

`publishAsync` invokes async subscribers sequentially.  
If you want parallel fan-out (fire-and-forget), call `publish` and handle async tasks inside the subscriber itself (e.g., `void doAsyncWork()`).

```ts
registrar.subscribe(PlayerJoinedEvent, (event) => {
  void sendWelcomeEmail(event.payload.playerId) // intentionally not awaited
})
```

---

## 6. Queuing & Retry Behaviour

The bus automatically queues events when published with no active subscribers and the event is not marked `isRePublishable`. Queued events will replay once a subscriber registers.

Important defaults (configurable via `EventBusOptions`):

| Option                | Default | Description                                               |
| --------------------- | ------- | --------------------------------------------------------- |
| `queueBatchSize`      | 10      | Items processed per flush                                 |
| `maxRetryAttempts`    | 5       | Retries before dropping a queued event                    |
| `queueTimeoutMs`      | 5000    | Timeout when replaying queued events                      |
| `eventTtlMs`          | 60000   | Time-to-live for queued events                            |
| `asyncTimeoutMs`      | 10000   | Timeout when awaiting async subscribers via `publishAsync` |

To instantiate a bus with custom options:

```ts
const bus = new EventBus(
  { asyncTimeoutMs: 15000, maxQueuedEvents: 200 },
  createEventLogger('NETWORK')
)
EventBus.configure(bus) // make it the singleton if needed
```

---

## 7. Logging

`EventBus` and `EventRegistrar` use the shared logging system via `createEventLogger`.  
To adjust verbosity, toggle `LOG_FLAGS` in `@lib/logging/logger.ts`.

```ts
import { createEventLogger } from '@lib/eventing'
const logger = createEventLogger('GAME_ENGINE', '[CardDeck]')
logger.logInfo('Deck initialised')
```

---

## 8. Testing

Use the helpers in `@lib/eventing/testing` (e.g., `createTestEventBus`) to get isolated buses for unit tests.

```ts
import { createTestEventBus } from '@lib/eventing/testing'
import { EventRegistrar } from '@lib/eventing'

it('publishes player events', async () => {
  const bus = createTestEventBus()
  const registrar = new EventRegistrar(bus)
  const handled: string[] = []

  registrar.subscribe(PlayerJoinedEvent, (event) => handled.push(event.payload.playerId))

  await bus.publish(new PlayerJoinedEvent({ playerId: '123', displayName: 'Alice' }))

  expect(handled).toEqual(['123'])
})
```

---

## 9. Recommended Patterns

- **Feature encapsulation** – Define events near the feature that owns them, export only what other domains require.
- **Strong typing** – Always include a static `eventType` to avoid name collisions and support queued delivery.
- **Error handling** – Wrap asynchronous subscribers in try/catch and report errors via `OperationResult.failure`.
- **Cleanup** – Call `dispose` on `EventRegistrar` instances to prevent memory leaks (React hooks do this automatically).
- **Docs** – If you build reusable behaviours, document them alongside `behaviours/README.md` so other teams can copy patterns.

---

## 10. Quick Reference

| Task                                | API / Helper                                    |
| ----------------------------------- | ----------------------------------------------- |
| Publish event                       | `EventBus.publish`, `EventBus.publishAsync`     |
| Subscribe / unsubscribe             | `EventRegistrar.subscribe`, `.unsubscribe`      |
| Await response from subscribers     | `createOperationDeferred`, `OperationResult`    |
| React integration                   | `EventBusProvider`, `useEventBus`, `useEventListener`, `useEventBehaviour` |
| Create prefixed logger              | `createEventLogger`                             |
| Generate GUID                       | `createGuid` (from `@lib/core`)                 |
| Timeout any promise                 | `withTimeout` (from `@lib/core`)                |


--- File: E:\Claim\src\lib\eventing\testing\createTestEventBus.ts ---
import { EventBus, type EventBusOptions } from '../EventBus';

export const createTestEventBus = (options?: EventBusOptions): EventBus => {
  return new EventBus(options);
};



--- File: E:\Claim\src\lib\eventing\__tests__\EventBus.spec.ts ---
import { describe, expect, it } from 'vitest';
import { EventBus, type EventBusOptions } from '../EventBus';
import { EventArgsBase } from '../base/EventArgsBase';

class TestEvent extends EventArgsBase {
  static readonly eventType = 'TestEvent';

  constructor(public readonly payload: number) {
    super();
  }
}

const createBus = (overrides: Partial<EventBusOptions> = {}) =>
  new EventBus({
    queueBatchSize: 4,
    maxRetryAttempts: 2,
    queueTimeoutMs: 50,
    maxQueuedEvents: 8,
    eventTtlMs: 50,
    asyncTimeoutMs: 50,
    ...overrides,
  });

const wait = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

describe('EventBus', () => {
  it('returns failure OperationResult when a synchronous subscriber throws', async () => {
    const bus = createBus();
    bus.subscribe(TestEvent, () => {
      throw new Error('subscriber failed');
    });

    const result = await bus.publish(new TestEvent(1));

    expect(result.isSuccess).toBe(false);
    expect(result.errorMessage).toContain('subscriber failed');
  });

  it('processes async subscribers sequentially when awaiting', async () => {
    const bus = createBus();
    const callOrder: Array<string> = [];

    bus.subscribeAsync(TestEvent, async () => {
      callOrder.push('first-start');
      await wait(5);
      callOrder.push('first-end');
    });

    bus.subscribeAsync(TestEvent, async () => {
      callOrder.push('second');
    });

    const result = await bus.publishAsync(new TestEvent(42));

    expect(result.isSuccess).toBe(true);
    expect(result.value).toBe(true);
    expect(callOrder).toEqual(['first-start', 'first-end', 'second']);
  });

  it('drops queued events that exceed TTL', async () => {
    const bus = createBus({
      queueBatchSize: 1,
      maxQueuedEvents: 2,
      eventTtlMs: 10,
      queueTimeoutMs: 10,
      asyncTimeoutMs: 10,
    });

    const firstResult = await bus.publish(new TestEvent(7));
    expect(firstResult.isSuccess).toBe(true);
    expect(firstResult.value).toBe(false); // queued

    await wait(20);

    let handled = false;
    bus.subscribe(TestEvent, () => {
      handled = true;
    });

    await wait(20);
    expect(handled).toBe(false);
  });
});



--- File: E:\Claim\src\lib\logging\index.ts ---
export * from './logger';
export * from './logStorage';
export * from './logBridge';
export * from './logApi';
export * from './logRouteHandler';
export * from './logQuery';




--- File: E:\Claim\src\lib\logging\logApi.ts ---
import { getLogStorage, type LogQuery } from './logStorage';
import { parseQueryParams, queryLogsFromParams, getLogStatsFromParams } from './logRouteHandler';

const LOG_API = false;

export function setupLogApiInterceptor(): void {
  if (typeof window === 'undefined') {
    return;
  }

  const originalFetch = window.fetch;

  window.fetch = async function (input: RequestInfo | URL, init?: RequestInit) {
    const url =
      typeof input === 'string'
        ? input
        : input instanceof URL
          ? input.toString()
          : input.url;

    if (url.includes('/api/logs/')) {
      try {
        if (url.includes('/api/logs/query')) {
          const params = parseQueryParams(url);
          const logs = await queryLogsFromParams(params);
          return new Response(
            JSON.stringify({
              success: true,
              count: logs.length,
              logs,
            }),
            {
              status: 200,
              headers: { 'Content-Type': 'application/json' },
            }
          );
        }

        if (url.includes('/api/logs/stats')) {
          const stats = await getLogStatsFromParams();
          return new Response(
            JSON.stringify({
              success: true,
              stats,
            }),
            {
              status: 200,
              headers: { 'Content-Type': 'application/json' },
            }
          );
        }
      } catch (error) {
        return new Response(
          JSON.stringify({
            success: false,
            error: error instanceof Error ? error.message : 'Internal error',
          }),
          {
            status: 500,
            headers: { 'Content-Type': 'application/json' },
          }
        );
      }
    }

    return originalFetch.call(this, input, init);
  };

  if (LOG_API) {
    console.log(
      '[Log API] Browser-side API interceptor active. /api/logs/* requests handled in browser.'
    );
  }
}

if (typeof window !== 'undefined') {
  const storage = getLogStorage();

  (window as Record<string, unknown>).__QUERY_LOGS__ = async (query: LogQuery = {}) => {
    return storage.queryLogs(query);
  };

  (window as Record<string, unknown>).__GET_LOG_STATS__ = async () => {
    return storage.getLogStats();
  };

  (window as Record<string, unknown>).__CLEAR_LOGS__ = async (query?: LogQuery) => {
    return storage.clearLogs(query);
  };

  if (LOG_API) {
    console.log(
      '[Log API] Log query functions available at window.__QUERY_LOGS__, window.__GET_LOG_STATS__, window.__CLEAR_LOGS__'
    );
  }
}




--- File: E:\Claim\src\lib\logging\logBridge.ts ---
/**
 * Log Bridge - Browser-side WebSocket bridge for MCP tools
 *
 * Uses BroadcastChannel for tab coordination to elect a single leader tab.
 * Only the leader tab opens WebSocket connection to Node.js server.
 *
 * Architecture:
 * - Multiple tabs can be open
 * - Only one tab is "leader" (handles MCP commands)
 * - Auto-election if leader closes
 * - Auto-reconnect on disconnect
 */

import { getLogStorage, type LogQuery } from './logStorage';

const LOG_MCP_BRIDGE = false;
const channel = new BroadcastChannel('mcp_bridge');

const tabId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
let isLeader = false;
let ws: WebSocket | null = null;
let wsState: 'disconnected' | 'connecting' | 'connected' = 'disconnected';
let reconnectTimeout: ReturnType<typeof setTimeout> | null = null;
let pingInterval: ReturnType<typeof setInterval> | null = null;

function becomeLeader(): void {
  if (isLeader) return;
  isLeader = true;
  if (LOG_MCP_BRIDGE) console.log('[LogBridge] This tab is now leader', tabId);
  connectWS();
}

function resignLeadership(): void {
  if (!isLeader) return;
  isLeader = false;
  if (LOG_MCP_BRIDGE) console.log('[LogBridge] Lost leadership');
  if (ws) {
    ws.close();
    ws = null;
  }
  if (reconnectTimeout) {
    clearTimeout(reconnectTimeout);
    reconnectTimeout = null;
  }
  if (pingInterval) {
    clearInterval(pingInterval);
    pingInterval = null;
  }
  wsState = 'disconnected';
}

function connectWS(): void {
  if (!isLeader) return;
  if (wsState === 'connecting' || wsState === 'connected') return;

  wsState = 'connecting';

  try {
    const port = window.location.port || '3000';
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.hostname}:${port}/ws`;

    if (LOG_MCP_BRIDGE) console.log('[LogBridge] Connecting to', wsUrl);
    ws = new WebSocket(wsUrl);

    ws.onopen = () => {
      if (!ws || ws.readyState !== WebSocket.OPEN || !isLeader) {
        return;
      }

      wsState = 'connected';
      if (LOG_MCP_BRIDGE) console.log('[LogBridge] Connected to Node.js server');

      startHeartbeat();

      try {
        channel.postMessage({ type: 'leader-connected', tabId });
      } catch {
        // ignore
      }
    };

    ws.onmessage = async event => {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        return;
      }

      try {
        const msg = JSON.parse(event.data);
        await handleMessage(msg);
      } catch (error) {
        if (LOG_MCP_BRIDGE) console.error('[LogBridge] Error handling message:', error);
      }
    };

    ws.onerror = error => {
      if (LOG_MCP_BRIDGE) console.error('[LogBridge] WebSocket error:', error);
    };

    ws.onclose = () => {
      wsState = 'disconnected';
      if (LOG_MCP_BRIDGE) console.log('[LogBridge] Disconnected from Node.js server');

      ws = null;

      stopHeartbeat();

      if (isLeader) {
        if (LOG_MCP_BRIDGE) console.log('[LogBridge] Reconnecting in 2s...');
        reconnectTimeout = setTimeout(() => {
          if (isLeader && wsState === 'disconnected') {
            connectWS();
          }
        }, 2000);
      }
    };
  } catch (error) {
    if (LOG_MCP_BRIDGE) console.error('[LogBridge] Failed to connect:', error);
    wsState = 'disconnected';

    if (isLeader) {
      reconnectTimeout = setTimeout(() => {
        if (isLeader) {
          connectWS();
        }
      }, 2000);
    }
  }
}

function startHeartbeat(): void {
  if (pingInterval) return;

  pingInterval = setInterval(() => {
    if (ws && wsState === 'connected' && ws.readyState === WebSocket.OPEN) {
      try {
        ws.send(JSON.stringify({ type: 'ping' }));
      } catch (error) {
        if (LOG_MCP_BRIDGE) console.error('[LogBridge] Heartbeat error:', error);
        stopHeartbeat();
        wsState = 'disconnected';
      }
    } else {
      stopHeartbeat();
    }
  }, 30000);
}

function stopHeartbeat(): void {
  if (pingInterval) {
    clearInterval(pingInterval);
    pingInterval = null;
  }
}

async function handleMessage(msg: { type: string; id?: string; params?: unknown }): Promise<void> {
  if (msg.type === 'pong') {
    return;
  }

  if (!msg.id) {
    if (LOG_MCP_BRIDGE) console.warn('[LogBridge] Message without ID:', msg);
    return;
  }

  try {
    let result: unknown;

    if (msg.type === 'query_logs') {
      const params = msg.params as LogQuery;
      const storage = getLogStorage();
      result = await storage.queryLogs(params);
    } else if (msg.type === 'get_log_stats') {
      const params = msg.params as { since?: string } | undefined;
      const storage = getLogStorage();
      if (params?.since) {
        const logs = await storage.queryLogs({ since: params.since, limit: 10000 });
        const stats = {
          total_logs: logs.length,
          by_level: {} as Record<string, number>,
          by_source: {} as Record<string, number>,
          by_context: {} as Record<string, number>,
          oldest_timestamp: logs.length > 0 ? Math.min(...logs.map(l => l.timestamp)) : null,
          newest_timestamp: logs.length > 0 ? Math.max(...logs.map(l => l.timestamp)) : null,
        };
        for (const log of logs) {
          stats.by_level[log.level] = (stats.by_level[log.level] || 0) + 1;
          stats.by_source[log.source] = (stats.by_source[log.source] || 0) + 1;
          stats.by_context[log.context] = (stats.by_context[log.context] || 0) + 1;
        }
        result = stats;
      } else {
        result = await storage.getLogStats();
      }
    } else if (msg.type === 'clear_logs') {
      const params = msg.params as LogQuery | undefined;
      const storage = getLogStorage();
      result = await storage.clearLogs(params);
    } else {
      throw new Error(`Unknown message type: ${msg.type}`);
    }

    if (ws && wsState === 'connected' && ws.readyState === WebSocket.OPEN) {
      try {
        ws.send(
          JSON.stringify({
            type: `${msg.type}_response`,
            id: msg.id,
            result,
          })
        );
      } catch (error) {
        if (LOG_MCP_BRIDGE) console.error('[LogBridge] Failed to send response:', error);
      }
    }
  } catch (error) {
    if (ws && wsState === 'connected' && ws.readyState === WebSocket.OPEN) {
      try {
        ws.send(
          JSON.stringify({
            type: `${msg.type}_response`,
            id: msg.id,
            error: error instanceof Error ? error.message : String(error),
          })
        );
      } catch (sendError) {
        if (LOG_MCP_BRIDGE) console.error('[LogBridge] Failed to send error response:', sendError);
      }
    }
  }
}

channel.onmessage = event => {
  const msg = event.data;

  if (msg.type === 'new-tab') {
    if (isLeader) {
      channel.postMessage({ type: 'leader-exists', tabId });
    }
  } else if (msg.type === 'leader-exists') {
    if (LOG_MCP_BRIDGE) console.log('[LogBridge] Leader exists, staying follower');
  } else if (msg.type === 'leader-dead' || msg.type === 'leader-disconnected') {
    if (!isLeader) {
      if (LOG_MCP_BRIDGE) console.log('[LogBridge] Leader gone, attempting election...');
      setTimeout(() => {
        if (!isLeader) {
          becomeLeader();
        }
      }, 100);
    }
  } else if (msg.type === 'leader-connected') {
    if (isLeader && msg.tabId !== tabId) {
      resignLeadership();
    }
  }
};

function startElection(): void {
  channel.postMessage({ type: 'new-tab', tabId });

  setTimeout(() => {
    if (!isLeader) {
      if (LOG_MCP_BRIDGE) console.log('[LogBridge] No leader found, self-electing');
      becomeLeader();
    }
  }, 300);
}

export function initLogBridge(): void {
  if (typeof window === 'undefined') return;

  if (LOG_MCP_BRIDGE) console.log('[LogBridge] Initializing...', tabId);

  startElection();

  window.addEventListener('beforeunload', () => {
    if (isLeader) {
      channel.postMessage({ type: 'leader-dead', tabId });
    }
    channel.close();
  });

  document.addEventListener('visibilitychange', () => {
    if (!document.hidden && isLeader && wsState === 'disconnected') {
      connectWS();
    }
  });
}

export function getBridgeStatus(): {
  isLeader: boolean;
  wsState: typeof wsState;
  tabId: string;
} {
  return {
    isLeader,
    wsState,
    tabId,
  };
}




--- File: E:\Claim\src\lib\logging\logger.ts ---
/**
 * Centralized Logging System
 *
 * Provides logging functions that write to both console (if enabled) and IndexedDB.
 * Similar to the Rust MCP pattern for persistent log storage.
 */

import { type LogLevel, type LogSource, getLogStorage } from './logStorage';

// Logging flags - set to true to enable console logging for specific modules
export const LOG_FLAGS = {
  UI: false, // UI component logs
  GAME_ENGINE: false, // Game engine logs
  AI: false, // AI related logs
  NETWORK: false, // Network related logs
  ASSETS: false, // Asset loading logs
  STORE: false, // Store/state management logs
};

// Global flag to enable/disable all console logging (including errors)
const LOG_ENABLED = false;

// Map module names to LogSource
const MODULE_TO_SOURCE: Record<keyof typeof LOG_FLAGS, LogSource> = {
  UI: 'UI',
  GAME_ENGINE: 'GameEngine',
  AI: 'System',
  NETWORK: 'Network',
  ASSETS: 'Assets',
  STORE: 'Store',
};

/**
 * Get context from stack trace (file/component name)
 */
function getContextFromStack(): string {
  try {
    const stack = new Error().stack;
    if (!stack) return 'Unknown';

    const lines = stack.split('\n');
    // Skip the first few lines (Error, getContextFromStack, log function)
    for (let i = 3; i < lines.length; i++) {
      const line = lines[i];
      if (!line) continue;

      // Try to extract file/component name
      // Match patterns like: at ComponentName (file.tsx:123:45)
      const match = line.match(/at\s+(\w+)\s+\([^)]+\)/);
      if (match && match[1]) {
        return match[1];
      }

      // Match patterns like: at file.tsx:123:45
      const fileMatch = line.match(/at\s+([^/]+\.(tsx?|jsx?)):/);
      if (fileMatch && fileMatch[1]) {
        return fileMatch[1].replace(/\.(tsx?|jsx?)$/, '');
      }
    }
  } catch {
    // Ignore errors in context extraction
  }

  return 'Unknown';
}

/**
 * Format log arguments into a message string
 */
function formatMessage(args: unknown[]): string {
  return args
    .map(arg => {
      if (typeof arg === 'object' && arg !== null) {
        try {
          return JSON.stringify(arg, null, 2);
        } catch {
          return String(arg);
        }
      }
      return String(arg);
    })
    .join(' ');
}

const logStoragePromise = (async () => {
  try {
    return getLogStorage();
  } catch {
    return null;
  }
})();

async function storeLogEntry(
  level: LogLevel,
  module: keyof typeof LOG_FLAGS,
  context: string,
  message: string,
  args: unknown[],
  stack?: string,
  tags?: string[]
): Promise<void> {
  try {
    const storage = await logStoragePromise;
    if (!storage) return;

    const source = MODULE_TO_SOURCE[module] || 'Other';

    await storage.storeLog({
      level,
      context,
      message,
      source,
      timestamp: Date.now(),
      args: args.length > 0 ? args : undefined,
      stack,
      tags: tags && tags.length > 0 ? tags : undefined,
    });
  } catch (error) {
    // Silently fail - don't break the app if log storage fails
    if (LOG_ENABLED) console.warn('[Logger] Failed to store log:', error);
  }
}

/**
 * Generic logging function
 */
export function log(module: keyof typeof LOG_FLAGS, level: LogLevel, ...args: unknown[]): void {
  const context = getContextFromStack();
  const message = formatMessage(args);

  // Write to console if enabled
  if (LOG_FLAGS[module]) {
    const consoleMethod =
      level === 'error'
        ? console.error
        : level === 'warn'
          ? console.warn
          : level === 'info'
            ? console.info
            : level === 'debug'
              ? console.debug
              : console.log;

    consoleMethod(`[${module}]`, ...args);
  }

  // Always store in IndexedDB (async, non-blocking)
  const stack = level === 'error' ? new Error().stack : undefined;

  // Auto-generate tags based on level and module
  const tags: string[] = [];
  if (level === 'error') tags.push('error', 'critical');
  if (level === 'warn') tags.push('warning');
  if (module === 'UI') tags.push('ui');
  if (module === 'GAME_ENGINE') tags.push('game');
  if (module === 'AI') tags.push('ai');
  if (module === 'NETWORK') tags.push('network');
  if (module === 'ASSETS') tags.push('assets');
  if (module === 'STORE') tags.push('store');

  storeLogEntry(level, module, context, message, args, stack, tags).catch(() => {
    // Ignore errors
  });
}

/**
 * Specific logging functions for each module
 */
export function logUI(...args: unknown[]) {
  log('UI', 'log', ...args);
}

export function logGameEngine(...args: unknown[]) {
  log('GAME_ENGINE', 'log', ...args);
}

export function logAI(...args: unknown[]) {
  log('AI', 'log', ...args);
}

export function logNetwork(...args: unknown[]) {
  log('NETWORK', 'log', ...args);
}

export function logAssets(...args: unknown[]) {
  log('ASSETS', 'log', ...args);
}

export function logStore(...args: unknown[]) {
  log('STORE', 'log', ...args);
}

/**
 * Error logging functions
 */
export function logError(module: keyof typeof LOG_FLAGS, ...args: unknown[]) {
  log(module, 'error', ...args);
}

export function logWarn(module: keyof typeof LOG_FLAGS, ...args: unknown[]) {
  log(module, 'warn', ...args);
}

export function logInfo(module: keyof typeof LOG_FLAGS, ...args: unknown[]) {
  log(module, 'info', ...args);
}

export function logDebug(module: keyof typeof LOG_FLAGS, ...args: unknown[]) {
  log(module, 'debug', ...args);
}

export type LogModule = keyof typeof LOG_FLAGS;

export interface ModuleLogger {
  logInfo(message: string, data?: unknown): void;
  logWarning(message: string, error?: unknown): void;
  logError(message: string, error?: unknown): void;
}

export function createModuleLogger(
  module: LogModule,
  options: { prefix?: string } = {}
): ModuleLogger {
  const { prefix } = options;
  const decorate = (message: string) => (prefix ? `${prefix} ${message}` : message);

  return {
    logInfo(message: string, data?: unknown) {
      if (typeof data !== 'undefined') {
        logInfo(module, decorate(message), data);
      } else {
        logInfo(module, decorate(message));
      }
    },
    logWarning(message: string, error?: unknown) {
      if (typeof error !== 'undefined') {
        logWarn(module, decorate(message), error);
      } else {
        logWarn(module, decorate(message));
      }
    },
    logError(message: string, error?: unknown) {
      if (typeof error !== 'undefined') {
        logError(module, decorate(message), error);
      } else {
        logError(module, decorate(message));
      }
    },
  };
}

/**
 * Auth-specific logging helper
 *
 * This function is designed for auth logging that uses flags.
 * It logs to console if the flag is enabled, and always stores to IndexedDB.
 *
 * @param flag - Whether to log to console
 * @param level - Log level
 * @param context - Context/module name (e.g., "FirebaseService", "AuthProvider")
 * @param args - Log arguments
 */
export async function logAuth(
  flag: boolean,
  level: LogLevel,
  context: string,
  ...args: unknown[]
): Promise<void> {
  const message = formatMessage(args);

  // Write to console if flag is enabled
  if (flag) {
    const consoleMethod =
      level === 'error'
        ? console.error
        : level === 'warn'
          ? console.warn
          : level === 'info'
            ? console.info
            : level === 'debug'
              ? console.debug
              : console.log;

    consoleMethod(`[${context}]`, ...args);
  }

  // Always store in IndexedDB (async, non-blocking)
  const stack = level === 'error' ? new Error().stack : undefined;

  // Auto-generate tags for auth logs
  const tags: string[] = ['auth'];
  if (level === 'error') tags.push('error', 'critical');
  if (level === 'warn') tags.push('warning');

  const storage = await logStoragePromise;
  if (!storage) {
    return;
  }

  storage
    .storeLog({
      level,
      context,
      message,
      source: 'Auth',
      timestamp: Date.now(),
      args: args.length > 0 ? args : undefined,
      stack,
      tags: tags.length > 0 ? tags : undefined,
    })
    .catch(() => {
      // Ignore errors
    });
}




--- File: E:\Claim\src\lib\logging\logQuery.ts ---
import { getLogStorage, type LogEntry, type LogQuery, type LogStats } from './logStorage';

export async function queryLogs(query: LogQuery = {}): Promise<LogEntry[]> {
  const storage = getLogStorage();
  return storage.queryLogs(query);
}

export async function getLogStats(): Promise<LogStats> {
  const storage = getLogStorage();
  return storage.getLogStats();
}

export async function clearLogs(query?: LogQuery): Promise<number> {
  const storage = getLogStorage();
  return storage.clearLogs(query);
}

export async function getRecentLogs(limit = 100): Promise<LogEntry[]> {
  return queryLogs({ limit });
}

export async function getErrorLogs(limit = 100, since?: string): Promise<LogEntry[]> {
  return queryLogs({ level: 'error', limit, since });
}

export async function getLogsBySource(
  source: 'Auth' | 'Network' | 'Assets' | 'GameEngine' | 'UI' | 'Store' | 'System' | 'Other',
  limit = 100
): Promise<LogEntry[]> {
  return queryLogs({ source, limit });
}

export async function getLogsByContext(context: string, limit = 100): Promise<LogEntry[]> {
  return queryLogs({ context, limit });
}




--- File: E:\Claim\src\lib\logging\logRouteHandler.ts ---
import { getLogStorage, type LogQuery } from './logStorage';

export interface QueryParams {
  level?: 'log' | 'error' | 'warn' | 'info' | 'debug';
  source?: 'Auth' | 'Network' | 'Assets' | 'GameEngine' | 'UI' | 'Store' | 'System' | 'Other';
  context?: string;
  since?: string;
  limit?: number;
  tags?: string[];
}

export function parseQueryParams(url: string): QueryParams {
  const urlObj = new URL(url, 'http://localhost');
  const params: QueryParams = {};

  const level = urlObj.searchParams.get('level');
  if (level && ['log', 'error', 'warn', 'info', 'debug'].includes(level)) {
    params.level = level as QueryParams['level'];
  }

  const source = urlObj.searchParams.get('source');
  if (source && ['Auth', 'Network', 'Assets', 'GameEngine', 'UI', 'Store', 'System', 'Other'].includes(source)) {
    params.source = source as QueryParams['source'];
  }

  const context = urlObj.searchParams.get('context');
  if (context) {
    params.context = context;
  }

  const since = urlObj.searchParams.get('since');
  if (since) {
    params.since = parseSinceParam(since);
  }

  const limit = urlObj.searchParams.get('limit');
  if (limit) {
    const limitNum = parseInt(limit, 10);
    if (!Number.isNaN(limitNum) && limitNum > 0 && limitNum <= 10000) {
      params.limit = limitNum;
    }
  }

  const tags = urlObj.searchParams.get('tags');
  if (tags) {
    params.tags = tags
      .split(',')
      .map(tag => tag.trim())
      .filter(Boolean);
  }

  return params;
}

function parseSinceParam(since: string): string {
  const relativeMatch = since.match(/^(\d+)([hdms])$/);
  if (relativeMatch) {
    const value = parseInt(relativeMatch[1], 10);
    const unit = relativeMatch[2];

    let ms = 0;
    switch (unit) {
      case 's':
        ms = value * 1000;
        break;
      case 'm':
        ms = value * 60 * 1000;
        break;
      case 'h':
        ms = value * 60 * 60 * 1000;
        break;
      case 'd':
        ms = value * 24 * 60 * 60 * 1000;
        break;
      default:
        ms = 0;
    }

    const timestamp = new Date(Date.now() - ms);
    return timestamp.toISOString();
  }

  return since;
}

export async function queryLogsFromParams(params: QueryParams) {
  const storage = getLogStorage();

  const query: LogQuery = {
    level: params.level,
    source: params.source,
    context: params.context,
    since: params.since,
    limit: params.limit ?? 1000,
  };

  let logs = await storage.queryLogs(query);

  if (params.tags && params.tags.length > 0) {
    logs = logs.filter(log => {
      const logTags = extractTagsFromLog(log);
      return params.tags!.some(tag => logTags.includes(tag));
    });
  }

  return logs;
}

export async function getLogStatsFromParams() {
  const storage = getLogStorage();
  return storage.getLogStats();
}

function extractTagsFromLog(log: { context: string; message: string }): string[] {
  const tags: string[] = [];

  const contextMatch = log.context.match(/LOG_\w+/g);
  if (contextMatch) {
    tags.push(...contextMatch);
  }

  const messageMatch = log.message.match(/LOG_\w+/g);
  if (messageMatch) {
    tags.push(...messageMatch);
  }

  return [...new Set(tags)];
}




--- File: E:\Claim\src\lib\logging\logStorage.ts ---
/**
 * Log Storage System
 *
 * Provides persistent IndexedDB storage for application logs, similar to the Rust MCP pattern.
 * Allows querying logs by level, source, context, and time range.
 */

// Log entry structure matching Rust MCP pattern
export interface LogEntry {
  id: string; // Unique ID (timestamp + random)
  level: LogLevel; // Log level (log, error, warn, info, debug)
  context: string; // Context/module name (e.g., "AuthProvider", "FirebaseService")
  message: string; // Log message
  source: LogSource; // Source type (Auth, Network, Assets, etc.)
  timestamp: number; // Timestamp in milliseconds
  args?: unknown[]; // Additional arguments passed to log
  stack?: string; // Stack trace for errors
  tags?: string[]; // Tags for filtering (e.g., ["auth", "critical"])
}

export type LogLevel = 'log' | 'error' | 'warn' | 'info' | 'debug';
export type LogSource =
  | 'Auth'
  | 'Network'
  | 'Assets'
  | 'GameEngine'
  | 'UI'
  | 'Store'
  | 'System'
  | 'Other';

// Query parameters for filtering logs
export interface LogQuery {
  level?: LogLevel; // Filter by log level
  context?: string; // Filter by context (partial match)
  source?: LogSource; // Filter by source
  since?: string; // RFC3339 timestamp (e.g., "2025-10-31T10:00:00Z")
  limit?: number; // Maximum number of results (1-10000, default 1000)
}

// Log statistics
export interface LogStats {
  total_logs: number;
  by_level: Record<LogLevel, number>;
  by_source: Record<LogSource, number>;
  by_context: Record<string, number>;
  oldest_timestamp: number | null;
  newest_timestamp: number | null;
}

/**
 * IndexedDB-based log storage
 */
export class LogStorage {
  private dbName = 'ClaimLogs';
  private storeName = 'logs';
  private version = 1;
  private db: IDBDatabase | null = null;
  private initialized = false;

  /**
   * Initialize the database
   */
  async initialize(): Promise<void> {
    if (this.initialized && this.db) {
      return;
    }

    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);

      request.onerror = () => {
        reject(new Error(`Failed to open IndexedDB: ${request.error}`));
      };

      request.onsuccess = () => {
        this.db = request.result;
        this.initialized = true;
        resolve();
      };

      request.onupgradeneeded = event => {
        const db = (event.target as IDBOpenDBRequest).result;

        // Create object store if it doesn't exist
        if (!db.objectStoreNames.contains(this.storeName)) {
          const store = db.createObjectStore(this.storeName, { keyPath: 'id' });
          // Create indexes for efficient querying
          store.createIndex('timestamp', 'timestamp', { unique: false });
          store.createIndex('level', 'level', { unique: false });
          store.createIndex('source', 'source', { unique: false });
          store.createIndex('context', 'context', { unique: false });
          // Compound index for common queries
          store.createIndex('level_timestamp', ['level', 'timestamp'], { unique: false });
          store.createIndex('source_timestamp', ['source', 'timestamp'], { unique: false });
        }
      };
    });
  }

  /**
   * Store a log entry
   */
  async storeLog(entry: Omit<LogEntry, 'id'>): Promise<void> {
    try {
      await this.initialize();
      if (!this.db) {
        throw new Error('Database not initialized');
      }

      const logEntry: LogEntry = {
        ...entry,
        id: `${entry.timestamp}-${Math.random().toString(36).substr(2, 9)}`,
      };

      return new Promise((resolve, reject) => {
        const transaction = this.db!.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);
        const request = store.add(logEntry);

        request.onerror = () => {
          reject(new Error(`Failed to store log: ${request.error}`));
        };

        request.onsuccess = () => {
          resolve();
        };
      });
    } catch (error) {
      // Silently fail - don't break the app if log storage fails
      console.warn('[LogStorage] Failed to store log:', error);
    }
  }

  /**
   * Query logs based on criteria
   */
  async queryLogs(query: LogQuery = {}): Promise<LogEntry[]> {
    try {
      await this.initialize();
      if (!this.db) {
        throw new Error('Database not initialized');
      }

      // Validate limit
      const limit = query.limit ?? 1000;
      if (limit === 0 || limit > 10000) {
        throw new Error('limit must be between 1 and 10000');
      }

      // Parse since timestamp if provided
      let sinceTimestamp: number | null = null;
      if (query.since) {
        // Check if it's a relative time (e.g., "1h", "24h", "7d")
        const relativeMatch = query.since.match(/^(\d+)([hdms])$/);
        if (relativeMatch) {
          const value = parseInt(relativeMatch[1], 10);
          const unit = relativeMatch[2];
          let ms = 0;
          switch (unit) {
            case 's':
              ms = value * 1000;
              break;
            case 'm':
              ms = value * 60 * 1000;
              break;
            case 'h':
              ms = value * 60 * 60 * 1000;
              break;
            case 'd':
              ms = value * 24 * 60 * 60 * 1000;
              break;
          }
          sinceTimestamp = Date.now() - ms;
        } else {
          // Try to parse as RFC3339 timestamp
          const date = new Date(query.since);
          if (Number.isNaN(date.getTime())) {
            throw new Error(
              `Invalid timestamp format: ${query.since}. Expected RFC3339 (e.g., "2025-01-01T00:00:00Z") or relative time (e.g., "1h", "24h", "7d")`
            );
          }
          sinceTimestamp = date.getTime();
        }
      }

      return new Promise((resolve, reject) => {
        const transaction = this.db!.transaction([this.storeName], 'readonly');
        const store = transaction.objectStore(this.storeName);

        // Use timestamp index for efficient sorting
        const index = store.index('timestamp');
        const request = index.openCursor(null, 'prev'); // Reverse order (newest first)

        const results: LogEntry[] = [];
        let scanCount = 0;
        const MAX_SCAN = 100000; // Prevent infinite loops

        request.onerror = () => {
          reject(new Error(`Failed to query logs: ${request.error}`));
        };

        request.onsuccess = event => {
          const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result;

          if (scanCount >= MAX_SCAN) {
            console.warn('[LogStorage] Query exceeded max scan limit');
            resolve(results);
            return;
          }

          if (!cursor) {
            // No more entries
            resolve(results);
            return;
          }

          scanCount++;
          const entry = cursor.value as LogEntry;

          // Apply filters
          if (this.matchesQuery(entry, query, sinceTimestamp)) {
            results.push(entry);
          }

          // Continue if we need more results
          if (results.length < limit) {
            cursor.continue();
          } else {
            resolve(results);
          }
        };
      });
    } catch (error) {
      console.error('[LogStorage] Query error:', error);
      return [];
    }
  }

  /**
   * Check if a log entry matches query criteria
   */
  private matchesQuery(entry: LogEntry, query: LogQuery, sinceTimestamp: number | null): boolean {
    // Filter by level
    if (query.level && entry.level !== query.level) {
      return false;
    }

    // Filter by source
    if (query.source && entry.source !== query.source) {
      return false;
    }

    // Filter by context (partial match)
    if (query.context && !entry.context.toLowerCase().includes(query.context.toLowerCase())) {
      return false;
    }

    // Filter by timestamp
    if (sinceTimestamp !== null && entry.timestamp < sinceTimestamp) {
      return false;
    }

    return true;
  }

  /**
   * Get log statistics
   */
  async getLogStats(): Promise<LogStats> {
    try {
      const allLogs = await this.queryLogs({ limit: 10000 });

      const stats: LogStats = {
        total_logs: allLogs.length,
        by_level: {
          log: 0,
          error: 0,
          warn: 0,
          info: 0,
          debug: 0,
        },
        by_source: {
          Auth: 0,
          Network: 0,
          Assets: 0,
          GameEngine: 0,
          UI: 0,
          Store: 0,
          System: 0,
          Other: 0,
        },
        by_context: {},
        oldest_timestamp: null,
        newest_timestamp: null,
      };

      for (const log of allLogs) {
        // Count by level
        stats.by_level[log.level]++;

        // Count by source
        stats.by_source[log.source]++;

        // Count by context
        stats.by_context[log.context] = (stats.by_context[log.context] || 0) + 1;

        // Track timestamps
        if (stats.oldest_timestamp === null || log.timestamp < stats.oldest_timestamp) {
          stats.oldest_timestamp = log.timestamp;
        }
        if (stats.newest_timestamp === null || log.timestamp > stats.newest_timestamp) {
          stats.newest_timestamp = log.timestamp;
        }
      }

      return stats;
    } catch (error) {
      console.error('[LogStorage] Failed to get stats:', error);
      return {
        total_logs: 0,
        by_level: { log: 0, error: 0, warn: 0, info: 0, debug: 0 },
        by_source: { Auth: 0, Network: 0, Assets: 0, GameEngine: 0, UI: 0, Store: 0, System: 0, Other: 0 },
        by_context: {},
        oldest_timestamp: null,
        newest_timestamp: null,
      };
    }
  }

  /**
   * Clear logs (optionally filtered)
   */
  async clearLogs(query?: LogQuery): Promise<number> {
    try {
      await this.initialize();
      if (!this.db) {
        throw new Error('Database not initialized');
      }

      // If query provided, delete matching logs
      if (query) {
        const logsToDelete = await this.queryLogs({ ...query, limit: 10000 });
        let deleted = 0;

        for (const log of logsToDelete) {
          await new Promise<void>((resolve, reject) => {
            const transaction = this.db!.transaction([this.storeName], 'readwrite');
            const store = transaction.objectStore(this.storeName);
            const request = store.delete(log.id);

            request.onerror = () => {
              reject(new Error(`Failed to delete log: ${request.error}`));
            };

            request.onsuccess = () => {
              deleted++;
              resolve();
            };
          });
        }

        return deleted;
      }

      // Otherwise, clear all logs
      return new Promise((resolve, reject) => {
        const transaction = this.db!.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);
        const request = store.clear();

        request.onerror = () => {
          reject(new Error(`Failed to clear logs: ${request.error}`));
        };

        request.onsuccess = () => {
          // Count is not available, so we'll need to query first
          this.queryLogs({ limit: 10000 })
            .then(logs => {
              resolve(logs.length);
            })
            .catch(reject);
        };
      });
    } catch (error) {
      console.error('[LogStorage] Failed to clear logs:', error);
      return 0;
    }
  }
}

// Singleton instance
let logStorageInstance: LogStorage | null = null;

/**
 * Get the global log storage instance
 */
export function getLogStorage(): LogStorage {
  if (!logStorageInstance) {
    logStorageInstance = new LogStorage();
  }
  return logStorageInstance;
}




--- File: E:\Claim\src\lib\logging\README.md ---
# Logging Library

`@lib/logging` provides a unified logging system with optional IndexedDB persistence, BroadcastChannel/WS bridging, query utilities, and integration points for other packages (e.g. `@lib/eventing`). This document explains the pieces available and how to use them effectively.

---

## 1. Overview

| Component        | Purpose                                                                                 |
| ---------------- | --------------------------------------------------------------------------------------- |
| `logger.ts`      | Central logging API (`logInfo`, `logError`, flags, auth helper).                        |
| `logStorage.ts`  | IndexedDB-backed storage; responsible for persisting and querying log records.          |
| `logBridge.ts`   | Browser WebSocket bridge for MCP tooling; coordinates leader tab via BroadcastChannel.  |
| `logApi.ts`      | Server-side utilities for exposing logs through HTTP (used by Vite middleware).         |
| `logRouteHandler.ts` | Express-style handler helpers for log querying endpoints.                           |
| `logQuery.ts`    | Client-side helper to fetch stored logs via API.                                        |

You can use the console-only helpers if you don’t need persistence. When `logStorage` is available, every log entry is also persisted asynchronously in IndexedDB and accessible to tools or other parts of the app.

---

## 2. Writing Logs

### 2.1 Simple module logging

```ts
import { logInfo, logWarn, logError } from '@lib/logging'

logInfo('GAME_ENGINE', 'Deck initialised', { cards: 52 })
logWarn('UI', 'Slow render detected', componentName)
logError('NETWORK', 'Failed to connect', error)
```

- The first argument is a module key defined in `LOG_FLAGS`.
- If the flag for the module is `true`, the message is echoed to the console.
- Regardless of the flag, the entry is stored (if storage is available).

### 2.2 Creating a prefixed logger

For repeated logging within a subsystem, use `createModuleLogger`.

```ts
import { createModuleLogger } from '@lib/logging'

const logger = createModuleLogger('ASSETS', { prefix: '[TextureLoader]' })

logger.logInfo('Loaded texture', { id: textureId })
logger.logWarning('Fallback to low-res asset')
logger.logError('Failed to decode texture', error)
```

This keeps format consistent and avoids repeating the module/prefix every time.

### 2.3 Auth-specific logging

`logAuth` accepts a runtime flag per call, allowing granular console control while still persisting records.

```ts
import { logAuth } from '@lib/logging'

const LOG_AUTH_FLOW = true

await logAuth(LOG_AUTH_FLOW, 'info', '[AuthProvider]', 'User signed in', userId)
```

---

## 3. Storing Logs

`logger.ts` automatically persists entries to IndexedDB via `logStorage`.  
Fetching the storage is asynchronous and graceful if unsupported.

```ts
import { getLogStorage } from '@lib/logging'

const storage = await getLogStorage()
await storage.storeLog({
  level: 'info',
  source: 'Custom',
  context: 'loadProfile',
  message: 'Profile loaded',
  args: [{ profileId }],
  timestamp: Date.now(),
})
```

`storeLog` is the low-level API used internally by the logger; most callers won’t interact with it directly.

---

## 4. Querying Logs

### 4.1 In-browser query helper

```ts
import { queryLogs } from '@lib/logging/logQuery'

const result = await queryLogs({
  since: '1h',
  level: 'error',
  source: 'Network',
  limit: 20,
})

console.table(result.logs)
```

`queryLogs` talks to the same HTTP endpoints exposed by the log API helper.

### 4.2 Server route helper

If you need a backend endpoint:

```ts
import express from 'express'
import { createLogRouteHandler } from '@lib/logging/logRouteHandler'

const router = express.Router()
router.get('/logs', createLogRouteHandler())
```

The handler parses query parameters, pulls logs from storage, and responds in JSON.

---

## 5. MCP / DevTools Bridge

`logBridge.ts` coordinates multiple browser tabs and forwards log entries via WebSocket to a Node.js peer—useful for external tooling (e.g. model control plane).

Key features:
- Leader election via `BroadcastChannel`.
- Automatic reconnect with backoff.
- Ping/pong health checks.

You can enable verbose bridge logging by flipping `LOG_MCP_BRIDGE` at the top of the file.

---

## 6. Configuration

Flags are defined in `logger.ts`:

```ts
export const LOG_FLAGS = {
  UI: false,
  GAME_ENGINE: false,
  AI: false,
  NETWORK: false,
  ASSETS: false,
  STORE: false,
}
```

Set any flag to `true` to mirror logs to the console in addition to persistent storage.

Global toggle `LOG_ENABLED` governs whether warnings about storage failures appear in console.

---

## 7. Integration with Other Packages

- **Eventing** uses `createEventLogger` (implemented on top of `createModuleLogger`) to emit bus diagnostics.
- **React behaviours / features** can create their own scoped loggers without reimplementing persistence.
- **Auth flows** rely on `logAuth` to tag entries appropriately (level + `auth` tags).

---

## 8. Tips

- **Batching** – If you’re logging in tight loops, consider throttling to avoid overwhelming IndexedDB.
- **Tags** – Provide extra context (e.g., `['error', 'critical']`) so queries can filter more precisely.
- **Time filters** – `queryLogs` accepts relative durations like `'30m'`, `'24h'`, or absolute ISO strings.
- **Storage errors** – All storage operations are fail-safe; they won’t throw to calling code. For debugging, temporarily enable `LOG_ENABLED`.

---

Need to add a new module? Extend `LOG_FLAGS` and optionally map it to a `LogSource` in `logStorage.ts`. Contributions welcome—update this README with new workflows as they arise.



--- File: E:\Claim\src\lib\react-behaviours\BehaviourHost.tsx ---
import { useEffect, useRef } from 'react';
import type { PropsWithChildren, ReactElement } from 'react';
import { ReactBehaviour } from './ReactBehaviour';

export interface BehaviourHostProps<
  TBehaviour extends ReactBehaviour<TContext>,
  TContext = undefined
> {
  create: (context: TContext | undefined) => TBehaviour;
  context?: TContext;
  onReady?: (behaviour: TBehaviour) => void;
  autoStart?: boolean;
}

export const BehaviourHost = <
  TBehaviour extends ReactBehaviour<TContext>,
  TContext = undefined
>({
  create,
  context,
  onReady,
  autoStart = true,
  children,
}: PropsWithChildren<BehaviourHostProps<TBehaviour, TContext>>): ReactElement | null => {
  const behaviourRef = useRef<TBehaviour | null>(null);

  useEffect(() => {
    const behaviour = create(context);
    behaviourRef.current = behaviour;
    behaviour.__initialize();
    onReady?.(behaviour);

    if (autoStart) {
      behaviour.start();
    } else {
      behaviour.enable();
    }

    return () => {
      behaviour.destroy();
      behaviourRef.current = null;
    };
  }, [create, context, onReady, autoStart]);

  return <>{children ?? null}</>;
};



--- File: E:\Claim\src\lib\react-behaviours\BehaviourScheduler.ts ---
import type { ReactBehaviour } from './ReactBehaviour';

interface ScheduledEntry {
  behaviour: ReactBehaviour<unknown>;
  targetInterval: number;
  lastTick: number;
}

type SchedulerHandle = {
  cancel(): void;
};

const scheduledBehaviours = new Map<ReactBehaviour<unknown>, ScheduledEntry>();
let rafHandle: number | null = null;
let intervalHandle: SchedulerHandle | null = null;

const hasAnimationFrame =
  typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function';

const now = (): number =>
  typeof performance !== 'undefined' && typeof performance.now === 'function'
    ? performance.now()
    : Date.now();

const runAnimationFrame = (callback: (time: number) => void): SchedulerHandle => {
  if (hasAnimationFrame) {
    const handle = window.requestAnimationFrame(callback);
    return {
      cancel() {
        window.cancelAnimationFrame(handle);
      },
    };
  }

  const intervalId = setTimeout(() => callback(now()), 16);
  return {
    cancel() {
      clearTimeout(intervalId);
    },
  };
};

const ensureScheduler = (): void => {
  if (scheduledBehaviours.size === 0) {
    stopScheduler();
    return;
  }

  if (rafHandle !== null || intervalHandle !== null) {
    return;
  }

  const tick = (time: number) => {
    for (const entry of scheduledBehaviours.values()) {
      const delta = time - entry.lastTick;
      if (delta >= entry.targetInterval) {
        entry.behaviour.__handleScheduledUpdate(delta);
        entry.lastTick = time;
      }
    }

    if (scheduledBehaviours.size === 0) {
      stopScheduler();
      return;
    }

    if (hasAnimationFrame) {
      rafHandle = window.requestAnimationFrame(tick);
    } else {
      intervalHandle = runAnimationFrame(tick);
    }
  };

  if (hasAnimationFrame) {
    rafHandle = window.requestAnimationFrame(tick);
  } else {
    intervalHandle = runAnimationFrame(tick);
  }
};

const stopScheduler = (): void => {
  if (rafHandle !== null && hasAnimationFrame) {
    window.cancelAnimationFrame(rafHandle);
  }
  rafHandle = null;

  if (intervalHandle) {
    intervalHandle.cancel();
  }
  intervalHandle = null;
};

export const registerBehaviourUpdate = (
  behaviour: ReactBehaviour<unknown>,
  targetFps: number
): void => {
  const targetInterval = Math.max(1, Math.round(1000 / targetFps));
  scheduledBehaviours.set(behaviour, {
    behaviour,
    targetInterval,
    lastTick: now(),
  });

  ensureScheduler();
};

export const unregisterBehaviourUpdate = (behaviour: ReactBehaviour<unknown>): void => {
  scheduledBehaviours.delete(behaviour);
  if (scheduledBehaviours.size === 0) {
    stopScheduler();
  }
};



--- File: E:\Claim\src\lib\react-behaviours\hooks\index.ts ---
export { useBehaviour } from './useBehaviour'
export type { UseBehaviourOptions } from './useBehaviour'
export { useBehaviourState } from './useBehaviourState'



--- File: E:\Claim\src\lib\react-behaviours\hooks\useBehaviour.ts ---
import { useEffect, useMemo } from 'react';
import { ReactBehaviour } from '../ReactBehaviour';

export interface UseBehaviourOptions {
  autoStart?: boolean;
}

export const useBehaviour = <
  T extends ReactBehaviour<TContext>,
  TContext = undefined
>(
  factory: (context: TContext | undefined) => T,
  context?: TContext,
  options?: UseBehaviourOptions
): T => {
  const autoStart = options?.autoStart ?? true;

  const behaviour = useMemo(() => {
    const instance = factory(context);
    instance.__initialize();
    return instance;
  }, [factory, context]);

  useEffect(() => {
    if (autoStart) {
      behaviour.start();
    } else {
      behaviour.enable();
    }

    return () => {
      behaviour.destroy();
    };
  }, [behaviour, autoStart]);

  return behaviour;
};



--- File: E:\Claim\src\lib\react-behaviours\hooks\useBehaviourState.ts ---
import { useEffect, useState } from 'react';
import { useBehaviour } from './useBehaviour';
import { ReactBehaviour } from '../ReactBehaviour';

type StateSelector<T extends ReactBehaviour, S> = (behaviour: T) => S;

interface UseBehaviourStateOptions {
  autoStart?: boolean;
}

export const useBehaviourState = <
  T extends ReactBehaviour<TContext>,
  S,
  TContext = undefined
>(
  factory: (context: TContext | undefined) => T,
  selector: StateSelector<T, S>,
  context?: TContext,
  options?: UseBehaviourStateOptions
): S => {
  const behaviour = useBehaviour(factory, context, options);
  const [state, setState] = useState(() => selector(behaviour));

  useEffect(() => {
    setState(selector(behaviour));
    return behaviour.__subscribeState(setState, selector);
  }, [behaviour, selector]);

  return state;
};



--- File: E:\Claim\src\lib\react-behaviours\index.ts ---
export { BehaviourHost } from './BehaviourHost'
export type { BehaviourHostProps } from './BehaviourHost'
export { registerBehaviourUpdate, unregisterBehaviourUpdate } from './BehaviourScheduler'
export { ReactBehaviour } from './ReactBehaviour'
export * from './hooks'



--- File: E:\Claim\src\lib\react-behaviours\ReactBehaviour.ts ---
import { registerBehaviourUpdate, unregisterBehaviourUpdate } from './BehaviourScheduler';

export type BehaviourStatus = 'created' | 'awake' | 'started' | 'destroyed';

export abstract class ReactBehaviour<TContext = undefined> {
  protected readonly context: TContext | undefined;
  private status: BehaviourStatus = 'created';
  private isEnabled = false;
  private readonly stateWatchers = new Set<(behaviour: this) => void>();
  private initialized = false;
  private isRegisteredForUpdates = false;

  constructor(context?: TContext) {
    this.context = context;
  }

  get currentStatus(): BehaviourStatus {
    return this.status;
  }

  get enabled(): boolean {
    return this.isEnabled;
  }

  __initialize(): void {
    if (this.initialized || this.status !== 'created') {
      return;
    }
    this.awake();
    this.initialized = true;
    this.status = 'awake';
  }

  enable(): void {
    if (this.isEnabled || this.status === 'destroyed') {
      return;
    }
    if (!this.initialized) {
      this.__initialize();
    }
    this.isEnabled = true;
    this.onEnable();
  }

  disable(): void {
    if (!this.isEnabled) {
      return;
    }
    this.isEnabled = false;
    this.onDisable();
  }

  start(): void {
    if (!this.initialized) {
      this.__initialize();
    }
    if (this.status !== 'awake') {
      return;
    }
    this.status = 'started';
    this.enable();
    this.onStart();
  }

  destroy(): void {
    if (this.status === 'destroyed') {
      return;
    }
    if (!this.initialized) {
      this.__initialize();
    }
    this.disable();
    this.onDestroy();
    this.stopUpdateLoop();
    this.initialized = false;
    this.status = 'created';
  }

  protected abstract awake(): void;

  protected onStart(): void {}

  protected onEnable(): void {}

  protected onDisable(): void {}

  protected onUpdate(_deltaTime?: number): void {
    void _deltaTime;
  }

  protected onLateUpdate(_deltaTime?: number): void {
    void _deltaTime;
  }

  protected onDestroy(): void {}

  protected startUpdateLoop(targetFps = 60): void {
    if (this.isRegisteredForUpdates) {
      return;
    }
    registerBehaviourUpdate(this as unknown as ReactBehaviour<unknown>, targetFps);
    this.isRegisteredForUpdates = true;
  }

  protected stopUpdateLoop(): void {
    if (!this.isRegisteredForUpdates) {
      return;
    }
    unregisterBehaviourUpdate(this as unknown as ReactBehaviour<unknown>);
    this.isRegisteredForUpdates = false;
  }

  protected notifyStateChanged(): void {
    for (const watcher of this.stateWatchers) {
      watcher(this);
    }
  }

  __subscribeState<S>(
    setState: (value: S) => void,
    selector: (behaviour: this) => S
  ): () => void {
    const watcher = (behaviour: this) => {
      setState(selector(behaviour));
    };

    this.stateWatchers.add(watcher);
    watcher(this);

    return () => {
      this.stateWatchers.delete(watcher);
    };
  }

  __handleScheduledUpdate(delta: number): void {
    if (!this.isEnabled) {
      return;
    }
    this.onUpdate(delta);
    this.onLateUpdate(delta);
  }
}



--- File: E:\Claim\src\lib\react-behaviours\README.md ---
# React Behaviours

`@lib/react-behaviours` provides a lightweight runtime for encapsulating stateful logic that lives alongside React components. Think of a “behaviour” as a small class with lifecycle hooks (`awake`, `onStart`, `onDestroy`), update loops, and state notification. This layer is used by `@lib/eventing/behaviours` but can also power other domains that need similar patterns.

---

## 1. Core Concepts

### 1.1 `ReactBehaviour`

Base class with lifecycle methods:

| Method            | When it fires                                              |
| ----------------- | ---------------------------------------------------------- |
| `awake`           | First initialisation; subscribe to events here.            |
| `onStart`         | Invoked when behaviour starts (after `enable`).            |
| `onEnable`/`onDisable` | Toggle when behaviour is enabled/disabled.            |
| `onUpdate`        | Called on each update tick if `startUpdateLoop` was used.  |
| `onLateUpdate`    | Runs after `onUpdate` within the same tick.                |
| `onDestroy`       | Cleanup logic, called from `destroy`.                      |

Behaviours hold a context object (`TContext`) if one is supplied, and expose `notifyStateChanged` for hooking into external observers.

### 1.2 `BehaviourHost`

React component that creates, starts, and destroys a behaviour automatically:

```tsx
import { BehaviourHost } from '@lib/react-behaviours'

<BehaviourHost
  create={() => new MyBehaviour()}
  autoStart={true}
  onReady={(behaviour) => {
    // optional callback once created
  }}
>
  {children}
</BehaviourHost>
```

### 1.3 Hooks

- `useBehaviour(factory, context?, options?)` – returns a behaviour instance bound to the component lifecycle.
- `useBehaviourState(factory, selector, context?, options?)` – subscribes to behaviour state via `notifyStateChanged`.

---

## 2. Creating a Behaviour

```ts
import { ReactBehaviour } from '@lib/react-behaviours'

interface PlayerState {
  score: number
  isReady: boolean
}

export class PlayerBehaviour extends ReactBehaviour {
  private state: PlayerState = { score: 0, isReady: false }

  get currentState(): PlayerState {
    return this.state
  }

  protected awake(): void {
    // Subscribe to external systems, register listeners, etc.
  }

  protected onStart(): void {
    this.loadInitialState()
  }

  protected onDestroy(): void {
    // Cleanup
  }

  private async loadInitialState() {
    this.state = { score: 10, isReady: true }
    this.notifyStateChanged()
  }
}
```

---

## 3. Using the Hooks

### 3.1 `useBehaviour`

```tsx
import { useBehaviour } from '@lib/react-behaviours'
import { PlayerBehaviour } from './PlayerBehaviour'

export function PlayerController() {
  const behaviour = useBehaviour(() => new PlayerBehaviour())

  useEffect(() => {
    behaviour.start()
  }, [behaviour])

  return null
}
```

`useBehaviour` creates the behaviour immediately (calling `awake`) and destroys it on unmount. By default it auto-starts; set `autoStart: false` in options to control it manually.

### 3.2 `useBehaviourState`

```tsx
import { useBehaviourState } from '@lib/react-behaviours'
import { PlayerBehaviour } from './PlayerBehaviour'

export function PlayerHUD() {
  const state = useBehaviourState(
    () => new PlayerBehaviour(),
    (behaviour) => behaviour.currentState
  )

  if (!state.isReady) return <div>Loading…</div>
  return <div>Score: {state.score}</div>
}
```

This hook wires `notifyStateChanged` into React, giving you a live view of the behaviour’s state.

---

## 4. Update Loops

Behaviours can schedule continuous updates:

```ts
protected onStart(): void {
  this.startUpdateLoop(30) // 30 FPS
}

protected onUpdate(deltaTime: number): void {
  // deltaTime is the elapsed time in ms since the last update
}

protected onDestroy(): void {
  this.stopUpdateLoop()
}
```

Internally, `BehaviourScheduler` manages update ticks using `requestAnimationFrame` (with a fallback to `setTimeout`).

---

## 5. Context Objects

You can pass contextual data when creating the behaviour:

```ts
type PlayerContext = { playerId: string }

const behaviour = useBehaviour(
  (context) => new PlayerBehaviour(context),
  { playerId: '123' }
)
```

Inside the behaviour:

```ts
constructor(context?: PlayerContext) {
  super(context)
  this.playerId = context?.playerId ?? 'unknown'
}
```

Behaviours created via `BehaviourHost` also receive the context you pass through the `context` prop.

---

## 6. Tips & Best Practices

- **Keep behaviours focused**: A behaviour should manage one slice of logic; compose multiple behaviours if needed.
- **Use `notifyStateChanged` sparingly**: Batch updates to avoid excessive React renders.
- **Cleanup**: Always call `stopUpdateLoop` and clean up subscriptions in `onDestroy`.
- **Optionally combine with EventBus**: Behaviours work well in tandem with `@lib/eventing` when you need bus-driven state.

---

Need more real-world examples? See `@lib/eventing/behaviours/README.md` for an event-driven variant built on top of this library. Contributions welcome—document reusable patterns here so others can adopt them quickly.


--- File: E:\Claim\src\lib\serialization\index.ts ---
export {
  configureSerialization,
  serializable,
  serialize,
  deserialize,
  SCHEMA_VERSION_KEY,
  getSerializableFields,
} from './Serializable'
export type { SerializableOptions, SerializableField } from './Serializable'



--- File: E:\Claim\src\lib\serialization\README.md ---
# Serialization Library

`@lib/serialization` offers decorators and helpers to mark classes as serializable, enforce schema versions, migrate data, and perform deep cloning / freezing. It is especially useful for persisting game layouts, editor state, or any object graph that needs to survive across sessions.

This README walks through the main APIs and how to integrate them.

---

## 1. Overview

| API / Type                | Purpose                                                                      |
| ------------------------- | ---------------------------------------------------------------------------- |
| `serializable` decorator  | Marks class fields as serializable with optional metadata (labels, min/max). |
| `serialize(instance)`     | Converts a decorated class instance into a JSON-friendly object.             |
| `deserialize(Class, data)` | Instantiates the class from serialized data (with optional migration).     |
| `configureSerialization`  | Adjust runtime options (deep clone, freeze results).                         |
| `getSerializableFields`   | Introspect metadata (useful for editors or tooling).                         |
| `SCHEMA_VERSION_KEY`      | Constant used to track version numbers during serialization.                 |

---

## 2. Decorating a Class

```ts
import { serializable } from '@lib/serialization'

export class PlayerSettings {
  @serializable({ label: 'Display Name' })
  name = 'Anonymous'

  @serializable({ label: 'Sound Volume', min: 0, max: 100 })
  volume = 70

  @serializable({ label: 'Favorite Deck', optional: true })
  deckId?: string
}
```

- `serializable` stores metadata via `reflect-metadata`. Ensure `import 'reflect-metadata'` is executed once (already done inside `Serializable.ts`).
- Options can include `label`, `min`, `max`, `step`, `group`, `inputType`, etc. These are primarily for UI introspection.

---

## 3. Serializing and Deserializing

```ts
import { serialize, deserialize } from '@lib/serialization'

const player = new PlayerSettings()
player.volume = 85

const raw = serialize(player)
// raw is a plain object safe to persist (e.g., JSON.stringify)

const restored = deserialize(PlayerSettings, raw)
// restored is a new PlayerSettings instance with volume = 85
```

Behind the scenes:

- `serialize` respects metadata, deep clones the object, and records `schemaVersion` (if provided).
- `deserialize` deep clones inputs, applies migrations when schema versions mismatch, and rehydrates decorated fields.

---

## 4. Schema Versions & Migration

Add a static `schemaVersion` to your class. Optionally provide a `migrate` function that accepts the raw serialized data when versions differ.

```ts
@serializable()
export class LayoutConfig {
  static schemaVersion = 2

  @serializable({ label: 'Table Size' })
  tableSize = 8

  @serializable({ label: 'Theme', optional: true })
  theme?: string

  static migrate(data: Record<string, unknown>) {
    if (data.__schemaVersion === 1) {
      // Example: rename property from "tableCount" -> "tableSize"
      if (typeof data.tableCount === 'number' && data.tableSize === undefined) {
        data.tableSize = data.tableCount
        delete data.tableCount
      }
    }
    data.__schemaVersion = LayoutConfig.schemaVersion
    return data
  }
}
```

When `deserialize(LayoutConfig, raw)` sees a different `__schemaVersion`, it calls `migrate` (if defined). You are responsible for updating the schema version inside the migration result.

---

## 5. Array and Nested Types

Use `elementType` to automatically deserialize array entries:

```ts
export class Deck {
  @serializable({ elementType: Card })
  cards: Card[] = []
}
```

If you omit `elementType`, arrays are cloned as plain values. When provided, `deserialize` recursively rehydrates each entry using the constructor.

---

## 6. Runtime Options

`configureSerialization` allows you to adjust three flags:

```ts
import { configureSerialization } from '@lib/serialization'

configureSerialization({
  deepClone: false,       // skip deep cloning (useful for performance, but mutates original)
  freezeResults: false,   // do not freeze serialized output
  freezeInstances: true,  // freeze deserialized class instances
})
```

Defaults:

- `deepClone`: true
- `freezeResults`: true
- `freezeInstances`: false

---

## 7. Inspecting Metadata

`getSerializableFields` returns raw metadata for generating editors or inspector UIs:

```ts
import { getSerializableFields } from '@lib/serialization'

const fields = getSerializableFields(PlayerSettings)
// [{ key: 'name', options: { label: 'Display Name' }, defaultValue: 'Anonymous', ... }, ...]
```

Each entry contains the original default value, options, and design type.

---

## 8. Testing & Utilities

- **Tests**: There’s an example spec in `__tests__/Serializable.spec.ts` demonstrating edge cases.
- **Helpers**: `Serializable.ts` exposes `SCHEMA_VERSION_KEY` for reading/writing version markers.
- **Deep clones**: Use the serializer to clone decorated objects safely (especially when classes contain nested serializable classes).

---

## 9. Tips

- Always update `schemaVersion` when changing the shape of serialized data, and implement a migration path.
- Keep migrations idempotent (safe to run multiple times).
- Remember to call `serialize` before storing to IndexedDB or sending over the network; never store class instances directly.
- Consider freezing instances (`freezeInstances`) in read-only contexts to catch accidental mutation.

---

Expand this README with additional patterns (e.g., diffing serialized output, patching) as they emerge.


--- File: E:\Claim\src\lib\serialization\Serializable.ts ---
import 'reflect-metadata';

export const SCHEMA_VERSION_KEY = '__schemaVersion';
const SERIALIZABLE_METADATA_KEY = Symbol('serializableFields');

type SerializableConstructor<T = unknown> = new () => T;
type SchemaAwareConstructor<T> = SerializableConstructor<T> & {
  schemaVersion?: number;
  migrate?: (data: Record<string, unknown>) => Record<string, unknown>;
};

interface SerializationRuntimeOptions {
  deepClone: boolean;
  freezeResults: boolean;
  freezeInstances: boolean;
}

const runtimeOptions: SerializationRuntimeOptions = {
  deepClone: true,
  freezeResults: true,
  freezeInstances: false,
};

const metadataCache = new WeakMap<SerializableConstructor, SerializableField[]>();
const serializableConstructors = new WeakSet<SerializableConstructor>();

export interface SerializableOptions {
  label?: string;
  min?: number;
  max?: number;
  step?: number;
  group?: string;
  inputType?: 'number' | 'angle' | 'string' | 'boolean';
  /**
   * When provided, array values will be deserialized using the supplied constructor.
   */
  elementType?: SerializableConstructor;
}

export interface SerializableField {
  key: string;
  options: SerializableOptions;
  defaultValue: unknown;
  designType?: SerializableConstructor | ArrayConstructor;
}

const isRecord = (value: unknown): value is Record<string, unknown> =>
  typeof value === 'object' && value !== null;

const isSerializableConstructor = (ctor: unknown): ctor is SerializableConstructor =>
  typeof ctor === 'function' && serializableConstructors.has(ctor as SerializableConstructor);

const deepClone = (value: unknown, seen = new WeakMap<object, unknown>()): unknown => {
  if (Array.isArray(value)) {
    return value.map(item => deepClone(item, seen));
  }

  if (value instanceof Date) {
    return new Date(value.getTime());
  }

  if (isRecord(value)) {
    if (seen.has(value)) {
      return seen.get(value);
    }
    const copy: Record<string, unknown> = {};
    seen.set(value, copy);
    for (const [key, entry] of Object.entries(value)) {
      copy[key] = deepClone(entry, seen);
    }
    return copy;
  }

  return value;
};

const deepFreeze = (value: unknown, seen = new WeakSet<object>()): unknown => {
  if (Array.isArray(value)) {
    if (!seen.has(value)) {
      seen.add(value);
      value.forEach(item => deepFreeze(item, seen));
    }
    return Object.freeze(value);
  }

  if (isRecord(value)) {
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    Object.entries(value).forEach(([, entry]) => {
      deepFreeze(entry, seen);
    });
    return Object.freeze(value);
  }

  return value;
};

export const configureSerialization = (
  options: Partial<SerializationRuntimeOptions>
): void => {
  Object.assign(runtimeOptions, options);
};

export function serializable(options: SerializableOptions = {}) {
  return function (target: object, propertyKey: string) {
    const constructor = (target as { constructor: SerializableConstructor }).constructor;
    serializableConstructors.add(constructor);

    const existing =
      (Reflect.getMetadata(
        SERIALIZABLE_METADATA_KEY,
        constructor
      ) as SerializableField[] | undefined) ?? [];

    const targetRecord = target as Record<string, unknown>;
    const designType = Reflect.getMetadata('design:type', target, propertyKey) as
      | SerializableConstructor
      | ArrayConstructor
      | undefined;

    existing.push({
      key: propertyKey,
      options,
      defaultValue: targetRecord[propertyKey],
      designType,
    });

    Reflect.defineMetadata(SERIALIZABLE_METADATA_KEY, existing, constructor);
    metadataCache.set(constructor, existing);
  };
}

export function getSerializableFields<T>(
  constructor: SerializableConstructor<T>
): SerializableField[] {
  const cached = metadataCache.get(constructor);
  if (cached) {
    return cached;
  }

  const fields =
    (Reflect.getMetadata(SERIALIZABLE_METADATA_KEY, constructor) as SerializableField[] | undefined) ??
    [];
  metadataCache.set(constructor, fields);
  return fields;
}

const serializeValue = (
  value: unknown,
  elementType: SerializableConstructor | undefined,
  visited: WeakSet<object>
): unknown => {
  if (value === null || value === undefined) {
    return value;
  }

  if (Array.isArray(value)) {
    return value.map(entry =>
      serializeValue(entry, elementType, visited)
    );
  }

  if (isRecord(value)) {
    if (visited.has(value)) {
      throw new Error('Circular reference detected while serializing object graph.');
    }
    visited.add(value);

    const ctor = (value as { constructor?: SerializableConstructor }).constructor;
    if (ctor && isSerializableConstructor(ctor)) {
      return serializeInternal(value, visited);
    }

    const cloned = runtimeOptions.deepClone ? (deepClone(value) as Record<string, unknown>) : { ...value };
    visited.delete(value);
    return cloned;
  }

  return value;
};

const serializeInternal = <T>(instance: T, visited: WeakSet<object>): Record<string, unknown> => {
  const ctor = (instance as { constructor: SchemaAwareConstructor<T> }).constructor;
  serializableConstructors.add(ctor);
  const fields = getSerializableFields(ctor);
  const source = instance as Record<string, unknown>;
  const result: Record<string, unknown> = {};

  for (const field of fields) {
    const value = source[field.key];
    result[field.key] = serializeValue(value, field.options.elementType, visited);
  }

  if (typeof ctor.schemaVersion === 'number') {
    result[SCHEMA_VERSION_KEY] = ctor.schemaVersion;
  }

  return runtimeOptions.freezeResults ? (deepFreeze(result) as Record<string, unknown>) : result;
};

export function serialize<T>(instance: T): Record<string, unknown> {
  const visited = new WeakSet<object>();
  return serializeInternal(instance, visited);
}

const deserializeArray = (
  raw: unknown,
  elementType?: SerializableConstructor
): unknown => {
  if (!Array.isArray(raw)) {
    return raw;
  }

  if (elementType && isSerializableConstructor(elementType)) {
    return raw.map(item =>
      isRecord(item) ? deserialize(elementType, item as Record<string, unknown>) : item
    );
  }

  return runtimeOptions.deepClone ? deepClone(raw) : [...raw];
};

const deserializeValue = (
  rawValue: unknown,
  field: SerializableField
): unknown => {
  if (rawValue === undefined) {
    return undefined;
  }

  if (Array.isArray(rawValue)) {
    return deserializeArray(rawValue, field.options.elementType);
  }

  if (isRecord(rawValue)) {
    if (field.options.elementType && isSerializableConstructor(field.options.elementType)) {
      return deserialize(field.options.elementType, rawValue as Record<string, unknown>);
    }

    if (field.designType && isSerializableConstructor(field.designType)) {
      return deserialize(field.designType, rawValue as Record<string, unknown>);
    }

    return runtimeOptions.deepClone ? deepClone(rawValue) : { ...rawValue };
  }

  return rawValue;
};

export function deserialize<T>(
  cls: SerializableConstructor<T>,
  json: Record<string, unknown>
): T {
  const schemaAwareCtor = cls as SchemaAwareConstructor<T>;
  const instance = new cls();
  const target = instance as Record<string, unknown>;

  let raw = runtimeOptions.deepClone ? (deepClone(json) as Record<string, unknown>) : { ...json };
  const incomingVersion = raw[SCHEMA_VERSION_KEY];
  delete raw[SCHEMA_VERSION_KEY];

  if (typeof schemaAwareCtor.schemaVersion === 'number') {
    if (incomingVersion === undefined) {
      console.warn(
        `[Serializable] Missing schema version for ${schemaAwareCtor.name}; expected ${schemaAwareCtor.schemaVersion}.`
      );
    } else if (incomingVersion !== schemaAwareCtor.schemaVersion) {
      if (typeof schemaAwareCtor.migrate === 'function') {
        raw = schemaAwareCtor.migrate({
          ...raw,
          [SCHEMA_VERSION_KEY]: incomingVersion,
        });
      } else {
        console.warn(
          `[Serializable] Schema version mismatch for ${schemaAwareCtor.name}. ` +
            `Found ${incomingVersion}, expected ${schemaAwareCtor.schemaVersion}.`
        );
      }
    }
  }

  const fields = getSerializableFields(cls);
  for (const field of fields) {
    if (Object.prototype.hasOwnProperty.call(raw, field.key)) {
      const value = deserializeValue(raw[field.key], field);
      if (value !== undefined) {
        target[field.key] = value;
      }
    } else if (field.defaultValue !== undefined) {
      target[field.key] =
        runtimeOptions.deepClone && isRecord(field.defaultValue)
          ? deepClone(field.defaultValue)
          : field.defaultValue;
    }
  }

  if (runtimeOptions.freezeInstances) {
    deepFreeze(instance);
  }

  return instance;
}


--- File: E:\Claim\src\lib\serialization\__tests__\Serializable.spec.ts ---
import { afterEach, describe, expect, it } from 'vitest';
import { configureSerialization, deserialize, serialize, serializable } from '../Serializable';

class ChildConfig {
  static schemaVersion = 1;

  @serializable()
  value = 1;
}

class ParentConfig {
  static schemaVersion = 1;

  @serializable({ elementType: ChildConfig })
  children: ChildConfig[] = [new ChildConfig()];

  @serializable()
  label = 'test';
}

describe('Serializable utilities', () => {
  afterEach(() => {
    configureSerialization({ deepClone: true, freezeResults: true, freezeInstances: false });
  });

  it('serializes nested serializable objects', () => {
    const parent = new ParentConfig();
    parent.children[0].value = 42;

    const json = serialize(parent);

    expect(json.label).toBe('test');
    expect(Array.isArray(json.children)).toBe(true);
    expect((json.children as Array<Record<string, unknown>>)[0].value).toBe(42);
    expect((json.children as Array<Record<string, unknown>>)[0].__schemaVersion).toBe(1);
  });

  it('deserializes nested serializable objects', () => {
    const json = {
      label: 'loaded',
      children: [{ value: 99, __schemaVersion: 1 }],
      __schemaVersion: 1,
    };

    const config = deserialize(ParentConfig, json);

    expect(config.label).toBe('loaded');
    expect(config.children[0]).toBeInstanceOf(ChildConfig);
    expect(config.children[0].value).toBe(99);
  });

  it('supports immutability toggles', () => {
    configureSerialization({ freezeResults: false, freezeInstances: true });

    const json = serialize(new ParentConfig());
    expect(Object.isFrozen(json)).toBe(false);

    const instance = deserialize(ParentConfig, json as Record<string, unknown>);
    expect(Object.isFrozen(instance)).toBe(true);
  });
});

